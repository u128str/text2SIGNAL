
















LIMIT clause




With the LIMIT clause, you can specify the number of rows to return. Normally, you use this clause together with the ORDER BY clause.


Without a LIMIT clause, the result set is limited to 500 rows by default. By setting the LIMIT clause, you can decrease or increase the default limit.


Syntax
:
SELECT expression
FROM table
LIMIT number




Parameter | Description
expression | The column or expression that you want to retrieve.
table | The process table or view from which you want to retrieve records, referenced by explicit Process ID or the alias THIS_PROCESS.
number | The number of rows in the result set.



Example
:
SELECT "Customer ID", case_id AS "Case ID","Order Status", city AS "City"
FROM THIS_PROCESS
WHERE ("city"='Boston')
ORDER BY 1 DESC
LIMIT 10



This query returns the first 10 rows where the customer Ids are sorted in descending order. It returns the customer IDs with orders from only Boston city.











﻿
















Window Frame




The window frame is the set of rows related to the current row where the window function is used to calculate the values of the defined window. You can define the window frame by using the ROW and RANGE modes.


The window frame contains a 
frame_start
 and a 
frame_end
. These frames are the start and end of your window frame.


In the 
frame_start
 you can add the following keywords:




- 
CURRENT ROW




- 
UNBOUND PRECEDING




- 
offset PRECEDING






In the 
frame_end
 you can add the following keywords:




- 
CURRENT ROW




- 
UNBOUNDED FOLLOWING




- 
offset FOLLOWING






The 
frame_start
 of CURRENT ROW means the frame starts with the current row's first peer row (a row that the window's ORDER BY clause sorts as equivalent to the current row). The 
frame_end
 of CURRENT ROW means the frame ends with the current row's last peer row.


The UNBOUNDED keyword is the first or last row of the peer group with the partition.


The 
offset
 expression's data type can vary depending on the data type of the ordering column. If you use numeric ordering columns, the type is the same as the ordering column. 


If the ordering column is of the type timestamp ('10 days'),  you can have the following RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING. The 
offset
 expression must be a non-null and non-negative value.




ROWS




With the ROWS mode, you can define the start and end of the window frame in terms of rows relevant to the current row. You can define the window frame with the ROWS mode in following ways:




- 
ROWS BETWEEN 10 PRECEDING AND CURRENT ROW




- 
ROWS BETWEEN 10 PRECEDING AND 10 FOLLOWING




- 
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING






 The UNBOUNDED keyword refers to the first or last row in a column or partition.




- 
UNBOUNDED PRECEDING is the first row




- 
UNBOUNDED FOLLOWING is the last row






If there is no ORDER BY clause, the returned results are undefined and the order in which the rows are processed isn't uniform.


An 
offset
 of 0 refers to the current row.


Syntax:
SELECT column name, SUM(column name)
OVER (ORDER BY column name ASC ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)



Parameter | Description
column name | The column name in your table you want to include in the function.



Example:


Consider the following table:



City | Value
Berlin | 1000
Paris | 3000
London | 2500
Paris | 1500

SELECT city, SUM(value) OVER (ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)


The following is returned:



City | Value
Berlin | 4000
Paris | 6500
London | 7000
Paris | 4000





RANGE




With the RANGE mode, you can define where the window frame starts and ends in window functions. When using the RANGE keyword the ORDER BY clause is required and you must specify one column name by which the window frame is ordered. Using the RANGE keyword is useful when working time series and when there are many gaps or duplicate data in your tables.


With the RANGE keyword, you can define the window frame by the maximum difference between the value of the column in the current row and its value in the preceding or following rows of the scope.


The RANGE mode only works with data types that are of the type interval, which are numbers and timestamps. Choice and Boolean data types aren't supported.


You can define the window frame with the RANGE mode in the following ways:




- 
ORDER BY attr RANGE BETWEEN 10 PRECEDING AND CURRENT ROW




- 
ORDER BY attr RANGE BETWEEN 1.0 PRECEDING AND 1.0 FOLLOWING




- 
ORDER BY attr RANGE BETWEEN DURATION "1day" PRECEDING AND DURATION "1hour" FOLLOWING




- 
ORDER BY attr RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING






Syntax:
SELECT column name , SUM(column name)
OVER (ORDER BY column name RANGE BETWEEN interval type PRECEDING AND interval type FOLLOWING)



Parameter | Description
column name | The column name in your table you want to include in the function.
interval type | Data type which are of type interval such as numbers (1.0) and timestamps ('10days').



Example:


Consider the following table:



City | Value
Berlin | 1000
Paris | 3000
London | 3000
Paris | 2000

SELECT city, SUM(value) OVER (ORDER BY value RANGE BETWEEN 1000.0 PRECEDING AND 1000.0 FOLLOWING)


The following is returned:



City | Value
Berlin | 3000.0
Paris | 9000.0
London | 8000.0
Paris | 8000.0






﻿
















Logical Expressions




A logical expression connects Boolean expressions using logical operators and can be evaluated to return a true or false value.


The following logical operators are available:



Operator | Description
AND | True if all the expressions separated by AND are true.
NOT | Negates the expression.
OR | True if any of the expressions separated by OR is true.





Syntax






AND, OR


expression1 AND | OR expression2



Parameters | Description
expression1 | The first expression to be evaluated.
expression2 | The second expression to be evaluted.



Operator Precedence




These two operators have different operator precedence. Specifically, AND takes precedence over OR. In compound expressions including both operators, this means that AND operations are evaluated before OR operations. For example, 

```
A OR B AND C
```

 is interpreted as

```
 A OR (B AND C)
```

 by default.


To override this and force OR operations to take precedence, enclose the relevant part of the expression in parentheses, for example, 

```
(A OR B) AND C
```

.




NOT





```
NOT(expression1)
```






Parameters | Description
expression1 | The expression to be negated.





Type Information




This table summarizes which combinations of data types are valid with the various logical operators and what type of result each combination yields.



Type of expression1 | Type of expression2 | Valid Operators | Result Type
Boolean | Boolean | AND, OR | Boolean
Boolean |  | NOT | Boolean





Examples






Example 1: Using AND Operator




The following example returns a list of delivered orders in the city of Boston. If the order status is delivered and the city is Boston, then the query returns the case IDs of these orders along with other details.
SELECT case_id, "City", "Order Status", "order amount"
FROM THIS_PROCESS
WHERE ("ORDER Status" = 'Delivered' AND "City" = 'Boston')
LIMIT 10


Result:


The query returns the following result.










Example 2: Using OR Operator




The following example returns orders where the value is less than 50 OR the value is greater than 2000 and city is Houston. Keep in mind the remark above noting how AND operations take precedence over OR operations.
SELECT case_id, "order amount", "Order Status", "city"
FROM THIS_PROCESS
WHERE ("Order amount" <= 50 OR "Order amount" >= 2000 AND "City" = 'Houston')
ORDER BY 2 DESC
LIMIT 15


Result:


The query returns the following result.










Example 3: Using NOT Operator




The following example returns the total order amount of all purchases excluding orders from the cities, Boston and Miami.
SELECT SUM("ORDER AMOUNT")
FROM THIS_PROCESS
WHERE NOT("City" = 'Boston' AND "City" = 'Miami')


Result:


The query returns the following result.











﻿


















 SELECT statement and clauses




In this section, it is explained how to use the SELECT statement and clauses in 
.




SELECT statement




The SELECT statement is used to select data from a process. It fetches data from columns and rows from the table. The data returned is the result set.


Syntax
:
SELECT expressions
FROM table
[TABLESAMPLE]
[WHERE]
[GROUP BY]
[UNION ALL]
[ORDER BY]
[FILL]
[LIMIT]
[OFFSET]	



Parameter | Description
expressions | The columns or calculations that you want to retrieve.
table | The process table or view from which you want to retrieve data. You can reference the process by using the explicit Process ID which can be found on the API tab in the process settings page. Alternatively you can use the alias THIS_PROCESS to refer to the default view.
TABLESAMPLE | Specify the absolute or percentage table fraction to be considered for the query.
WHERE condition | The condition that must be met for the records to be selected. If no condition is provided, then all records are selected.
ORDER BY index | The index of a selected expression used to sort the records in the result set. If more than one expression is provided, separate the values with a comma.
ASC sorts the result set in ascending order by expression, DESC sorts it in descending order.
NULLS FIRST sorts the result set with null values first, NULLS LAST with null values last.
GROUP BY | Collects data across multiple records and group the results by one or more columns. The GROUP BY clause requires an index similar to the ORDER BY clause. You can use one or multiple indices.
UNION ALL | Concatenates the result sets of two or more SELECT statements.
FILL | Function to fill results.
LIMIT | The number of records in the result set.
OFFSET | The starting point to return rows from a result set.



Example:
SELECT column1, column2
FROM table



Parameter | Description
column1, column2 | The columns from which you want to retrieve records.
table | The process table or view from which you want to retrieve records, referenced by explicit Process ID or the alias THIS_PROCESS.



This query returns the data of 
column1
 and 
column2
 from the specified table.


Only little effort is required to select multiple attributes and order and limit the result set.


Example:
SELECT case_id, Status, "Customer ID"
FROM table
ORDER BY 2 DESC
LIMIT 10


This query returns the case ID, status, and customer ID of the first 10 cases in the table. 
ORDER BY 2 DESC
 indicates to order the result set by the second column, which is 
Status
, in descending order.




Subqueries




A subquery is a query that is nested inside a 
SELECT
 statement or inside another subquery. You can use a subquery anywhere an expression is allowed to retrieve data on event-level.


Subqueries are allowed in the FROM clause as well as in the FLATTEN operator.


Syntax
:
SELECT (
SELECT(event_name))
FROM table



Parameter | Description
event_name | The column or expression from which you want to retrieve the first element.
table | The process table or view from which you want to retrieve records, referenced by explicit Process ID or the alias THIS_PROCESS.









Example 1 (subquery in the AVG function)
:




SELECT "City" AS "Sales Region",
AVG((SELECT LAST("end_time")-FIRST("end_time"))) AS "AVG Cycle Time"
FROM THIS_PROCESS
ORDER BY 2 ASC


This query returns the average cycle time per city.










Example 2 (subquery in the SUM function)
:




SELECT SUM(
(SELECT SUM(IF("event_name"='T-shirt Printed',1,0))))
FROM THIS_PROCESS


This query maps a number to an event and sums the numbers up to count the number of occurrences of this event.










Example 3 (subquery in the FROM clause)
:




SELECT "City" AS City, "C" AS "Cases", C /877 *100 AS "Percentage"
FROM (
SELECT "City", COUNT (1) AS "C"
FROM THIS_PROCESS
GROUP BY 1)
AS sub


This query returns the cities, the cases per city, and the percentage of cases per city.






Example:
























Example 4 (subquery in the FLATTEN operator)
:




SELECT COUNT(1)AS "Number","event_name" AS "Event"
FROM FLATTEN ((
SELECT "event_name"
FROM THIS_PROCESS
WHERE (SELECT LAST("end_time") - FIRST("end_time") > DURATION '31days')
) AS Sub)


This query returns the events and their occurrences for all cases that took longer than 31 days.






Example























﻿
















Non-aggregate functions




The following functions are used with individual rows as part of a window function.




LEAD




Returns a single column value from the succeeding row according to the window partition and sort criteria. When no succeeding row exists, a null value is returned.




Syntax





```
LEAD(columnName) OVER (PARTITION BY partitionExpression ORDER BY sortExpression)
```






Parameter | Description
columnName | The column from the succeeding row to be included in the current row.
partitionExpression | An expression determining how the rows are grouped.
sortExpression | An expression determining how each partition is sorted.





Example




This query partitions data by case ID, sorting each partition chronologically. Each row includes the case ID and event name along with two additional columns:




- 
The event name from the next row




- 
The difference between the timestamps of the current and succeeding rows






The result shows the name of each event that occurred, the name of the succeeding event and how much time separates the two events. For events having no successor, a null value is displayed.

```
SELECT    case_id,    event_name AS Event,    LEAD(event_name) OVER (PARTITION BY case_id ORDER BY end_time) AS Successor,    LEAD(end_time) OVER (PARTITION BY case_id ORDER BY end_time) - end_time AS CycleTimeFROM FLATTEN(THIS_PROCESS
```

)






Example output:


















LAG




Returns a single column value from the preceding row according to the window partition and sort criteria. When no preceding row exists, a null value is returned.




Syntax





```
LAG(columnName) OVER (PARTITION BY partitionExpression ORDER BY sortExpression)
```






Parameter | Description
columnName | The column from the preceding row to be included in the current row.
partitionExpression | An expression determining how the rows are grouped.
sortExpression | An expression determining how each partition is sorted.





Example




This query partitions data by case ID, sorting each partition chronologically. Each row includes the case ID and event name along with two additional columns:




- 
The event name from the preceding row




- 
The difference between the timestamps of the preceding and current rows






The result shows the name of each event that occurred, the name of the preceding event and how much time separates the two events. For events having no predecessor, a null value is displayed.

```
SELECT    case_id,    LAG(event_name) OVER (PARTITION BY case_id ORDER BY end_time) AS Predecessor,    event_name AS Event,    end_time - LAG(end_time) OVER (PARTITION BY case_id ORDER BY end_time) AS cycle_timeFROM FLATTEN(THIS_PROCESS)
```







Example output:



















﻿
















UNION ALL clause




With the UNION ALL operator, you can combine the result sets of two or more SELECT statements. The amount of table columns and column data types must match for each SELECT statement when using the  UNION ALL operator.


Syntax
:
SELECT expression
FROM tables
[WHERE conditions]
TABLESAMPLE sampling method (sampling amount) REPEATABLE (seed)
ORDER BY order_index [, ...] [ASC | DESC] [NULLS FIRST | NULLS LAST]
UNION ALL
SELECT expression
FROM tables
[WHERE conditions]
TABLESAMPLE sampling method (sampling amount) REPEATABLE (seed)
ORDER BY order_index [, ...] [ASC | DESC] [NULLS FIRST | NULLS LAST]



Parameter | Description
expression | The column or expression that is queried.
tables | The tables from which you want to retrieve records. At least one table must be listed in the FROM clause.
conditions | (Optional) Conditions that must be met in order for the records to be selected.



SELECT statements before and after UNION ALL can only have the following clauses:
SELECT expressions
FROM table
[TABLESAMPLE]
[WHERE]
[GROUP BY]


Any other clauses, for example the UNION ALL, ORDER BY, FILL, LIMIT, and OFFSET are applied to the result of UNION ALL.


Example 1
:
SELECT case_id AS "Case ID"
FROM
(
SELECT case_id
FROM THIS_PROCESS
UNION ALL
SELECT case_id
FROM THIS_PROCESS
) as sub
ORDER BY 1
LIMIT 20


This query returns a combined result set of the 
case_id
s from tables in a column.








Example 2
:

SELECT case_id, ts, is_first
FROM
(
SELECT
case_id, DATE_TRUNC('day', (SELECT FIRST(end_time))) AS ts,
1.0 AS is_first
FROM THIS_PROCESS
UNION ALL
SELECT
case_id, DATE_TRUNC('day', (SELECT LAST(end_time)) + DURATION '1day') AS ts,
0.0 as is_first
FROM THIS_PROCESS
) AS sub
ORDER BY 1,2,3
LIMIT 20


This query returns a combined result set of dates where an event was either open or closed on the given date. A time-stamp  (ts) is used, where 1 means the event is open and 0 means the event is closed on the respective dates.











﻿
















Comparison Expressions




Comparison expressions evaluate to true or false by comparing the values of two expressions.


The following comparison operators are available:



Operator | Description
< | Less than
> | Greater than
<= | Less than or equal to
>= | Greater than or equal to
= | Equal to
<> | Not equal to





Syntax


expression1 = | <> | < | <= | > | >= expression2



Parameters | Description
expression1 | The first expression to be compared.
expression2 | The second expression to be compared.





Type Information




This table summarizes which combinations of data types are valid with the various comparison operators and what type of result each combination yields.



Type of expression1 | Type of expression2 | Valid Operators | Result Type
Number | Number | =, <>, <, <=, =>, > | Boolean
Timestamp | Timestamp | =, <>, <, <=, =>, > | Boolean
Duration | Duration | =, <>, <, <=, =>, > | Boolean
Text | Text | =, <> | Boolean
Boolean | Boolean | =, <>, <, <=, =>, > | Boolean





When comparing Boolean types, false < true.






Examples






Example 1




The following example query uses the comparison operations, '>', '<', and '=' for defining conditions in the WHERE clause. It returns a list of delivered orders whose order amount is between 100 and 900. If the order status is 'Delivered' and the order amount is greater than  100 and less than 900, then the query returns the case IDs of these orders along with other details.
SELECT case_id, "order amount", "Order Status"
FROM THIS_PROCESS
WHERE ("ORDER Status" = 'Delivered' AND "order amount" > 100 AND "order amount" < 900)
LIMIT 10


Result:


The query returns the following result.










Example 2




The following example query uses the comparison operations, '>=', '<=', and '<>' for defining conditions in the WHERE clause. It returns a list of orders that are not delivered and with the order amount between 300 and 2000. If the order status is not 'Delivered' and the order amount is greater than or equal to 300 and less than or equal to 2000, then the query returns the case IDs of these orders along with other details.
SELECT "case_id", "ORDER AMOUNT" AS "Orders between 300to2000", "order status"
FROM THIS_PROCESS
WHERE ("order amount" >= 300 AND "order amount" <= 2000 AND "Order status" <> 'Delivered')
LIMIT 10


Result:


The query returns the following result.








 





﻿
















The  code editor




This section describes the features of the 
 code editor.


You work in the 
 code editor when configuring the following:




- 
metrics




- 
widgets




- 
advanced filters on dashboards




- 
rules for actions








Autocompletion




Autocompletion helps you to quickly write 
 queries while minimizing typing and syntax errors.


The autocomplete support is location-specific.  For example, if your cursor is in the SELECT area of the query, suggestions include attributes and metrics. In other areas of the query, autocompletion provides support for query operators, functions, and expressions.




- 
To trigger autocompletion, press Ctrl + Space for Windows or control + Space for Mac. This opens a list and you can select a completion. The list of items is filtered and narrowed down as you type.






On a Mac, if the shortcut doesn't work, this combination of keystrokes is probably mapped to some other function. Check and change the mapping under 
 System Settings > Keyboard > Keyboard Navigation > Keyboard Shortcuts
.




Color scheme




The color scheme for code simplifies reading and writing queries.


The different pieces of code are colored as follows:




- 
keywords are pink, for example, SELECT, GROUP BY, and FROM




- 
functions are yellow, for example, COUNT, MAX, and FLATTEN




- 
identifiers are green, for example, attributes and table names




- 
comments are orange






Colored 
 code example:










Error linting




The 
 code editor provides a linter that parses the code to detect errors. Each error in a row is indicated by a wavy underscore. If available, additional information is displayed when you hover the error.


Error linting example:










Next steps






Add metrics to a process


















Advanced filter






Actions






SAP Signavio Analytics Language







﻿
















Matching expressions




Do not combine the MATCHES expression with the FLATTEN expression.




The MATCHES expressions work only for nested tables and not for flattened tables.






MATCHES




The MATCHES expression allows filtering based on patterns that check for a certain sequence of event-level values, such as event_name.




Syntax



expression
 MATCHES (
pattern
)




Parameter | Description
expression | The column or expression that is compared with the defined pattern.
pattern | The defined pattern with which the expression is compared.







Pattern syntax
Description




A -> B
"A" directly followed by "B" (can be omitted)


A ~> B
"A" indirectly or directly followed by "B". Equivalent to A ANY* B


^ A
Sequence starts with "A" in any specific case


B $
Sequence ends with "B" in any specific case


A ANY B
"A" is followed by any single value which is then followed by "B"


A ANY* B
"A" is followed by any number of values which are then followed by "B"


NULL
Sequence contains "Null" values


NOT A
All values that are not "A" (even if the sequence contains A values)


A NOT B
"A" directly followed by a value that is not "B"


A NOT (B | C)
"A" directly followed by a value that is not "B" or "C"


(A | B)
"A" or "B" | Pattern syntax | Description | A -> B | "A" directly followed by "B" (can be omitted) | A ~> B | "A" indirectly or directly followed by "B". Equivalent to A ANY* B | ^ A | Sequence starts with "A" in any specific case | B $ | Sequence ends with "B" in any specific case | A ANY B | "A" is followed by any single value which is then followed by "B" | A ANY* B | "A" is followed by any number of values which are then followed by "B" | NULL | Sequence contains "Null" values | NOT A | All values that are not "A" (even if the sequence contains A values) | A NOT B | "A" directly followed by a value that is not "B" | A NOT (B | C) | "A" directly followed by a value that is not "B" or "C" | (A | B) | "A" or "B"
Pattern syntax | Description
A -> B | "A" directly followed by "B" (can be omitted)
A ~> B | "A" indirectly or directly followed by "B". Equivalent to A ANY* B
^ A | Sequence starts with "A" in any specific case
B $ | Sequence ends with "B" in any specific case
A ANY B | "A" is followed by any single value which is then followed by "B"
A ANY* B | "A" is followed by any number of values which are then followed by "B"
NULL | Sequence contains "Null" values
NOT A | All values that are not "A" (even if the sequence contains A values)
A NOT B | "A" directly followed by a value that is not "B"
A NOT (B | C) | "A" directly followed by a value that is not "B" or "C"
(A | B) | "A" or "B"





Example 1




Match cases where the first event is “Receive Customer Order” and the event “Receive Delivery Confirmation” occurs at any point later on.

```
SELECT case_id, event_nameFROM THIS_PROCESSWHERE event_name MATCHES(^'Receive Customer Order' ~> 'Receive Delivery Confirmation')
```



Output:










Example 2




Match cases where exactly one event of any kind occurs between a payment being received and the order being canceled.

```
SELECT case_id, event_nameFROM THIS_PROCESSWHERE "event_name" MATCHES ('Receive Payment' ANY 'Order Canceled')
```



Output:




BEHAVIOUR MATCHES




The BEHAVIOUR MATCHES expression checks whether complex behavior matches a pattern. Up to eight behaviors can be combined. For each behavior an alias must be given. Behaviors can be specified using comparison operators.




Syntax




```
BEHAVIOUR (expression) AS alias_name [, (expression) AS alias_name, ...] MATCHES (pattern)
```




Parameter | Description
expression | The column or expression with a defined behavior that is compared with the defined pattern.
alias_name | The temporary name to assign.
Enclose the name in double quotes if it contains a character that isn't a letter or digit.
pattern | The complex pattern the expression is compared with.







Pattern syntax
Description




A -> B
"A" directly followed by "B" (can be omitted)


A ~> B
"A" indirectly or directly followed by "B". Equivalent to A ANY* B


^ A
Sequence starts with "A" in any specific case


B $
Sequence ends with "B" in any specific case


A ANY B
"A" is followed by any single value which is then followed by "B"


A ANY* B
"A" is followed by any number of values which are then followed by "B"


NOT A
All values that are not "A" (even if the sequence contains A values)


A NOT B
"A" directly followed by a value that is not "B"


A NOT (B | C)
"A" directly followed by a value that is not "B" or "C"


(A | B)
"A" or "B" | Pattern syntax | Description | A -> B | "A" directly followed by "B" (can be omitted) | A ~> B | "A" indirectly or directly followed by "B". Equivalent to A ANY* B | ^ A | Sequence starts with "A" in any specific case | B $ | Sequence ends with "B" in any specific case | A ANY B | "A" is followed by any single value which is then followed by "B" | A ANY* B | "A" is followed by any number of values which are then followed by "B" | NOT A | All values that are not "A" (even if the sequence contains A values) | A NOT B | "A" directly followed by a value that is not "B" | A NOT (B | C) | "A" directly followed by a value that is not "B" or "C" | (A | B) | "A" or "B"
Pattern syntax | Description
A -> B | "A" directly followed by "B" (can be omitted)
A ~> B | "A" indirectly or directly followed by "B". Equivalent to A ANY* B
^ A | Sequence starts with "A" in any specific case
B $ | Sequence ends with "B" in any specific case
A ANY B | "A" is followed by any single value which is then followed by "B"
A ANY* B | "A" is followed by any number of values which are then followed by "B"
NOT A | All values that are not "A" (even if the sequence contains A values)
A NOT B | "A" directly followed by a value that is not "B"
A NOT (B | C) | "A" directly followed by a value that is not "B" or "C"
(A | B) | "A" or "B"



Example
:


Match cases where a small payment was followed at some point by larger payment.

```
SELECT case_id, event_name, "Payment Amount"FROM THIS_PROCESSWHERE BEHAVIOUR    (event_name = 'Receive Payment' AND "Payment Amount" < 100) AS changed_small_amount,    (event_name = 'Receive Payment' AND "Payment Amount" >= 100) AS changed_large_amountMATCHES (changed_small_amount ~> changed_large_amount)
```











IN





IN | True if the operand is equal to at least one of a list of literal values






﻿














Count cases and cities




You want to get an overview about the case attributes of the process: How many cases exist for this process? How many different cities are involved in this process? How many cases exist for each city? How many cases exist for New York and Miami?




Example 1: How many cases exist for this process?




Learning success: Count a case attribute.


Query instruction: 
Count
 
keyword: COUNT
 all 
cases
 
expression: case_id
 in this process.


 syntax:
SELECT
COUNT(case_id)
FROM THIS_PROCESS


Query result: The total number of cases, displayed in a 
 widget.










Example 2: How many different cities are involved in this process?




Learning success: Count the distinct records of a case attribute.


Query instruction: 
Count
 
keyword: COUNT
 all 
cities
 
expression: City
 in this process. Unlike example 1, only 
distinct
 
keyword: DISTINCT
 records are counted.


 syntax:
SELECT
COUNT(DISTINCT City)
FROM THIS_PROCESS


Query result: The total number of distinct cities, displayed in a 
 widget:










Example 3: How many cases exist for each city?




Learning success:




- 
Count two or more case attributes.




- 
Rename case attribute names with alias names.




- 
Sort the result set.






Query instruction: 
Count
 
keyword: COUNT
 the number of 
cases
 
expression: case id
 by 
city
 
expression: City
. Rename the case attribute names with 
aliases
 
keyword: AS
 to "Case Number" and "Site". This makes labels for widgets easier to understand. Finally 
sort the result set by Case numbers
 
keywords: ORDER BY 1
 in 
descending order
 
keyword: DESC
.


The order expression 1 selects the column, which has to be sorted. You can sort in 
ascending order
 
keyword: ASC
, 
descending order
 
keyword: DESC
, by 
null values first
 
keyword: NULLS FIRST,
 or by 
null values last
 
keyword: NULLS LAST
.


 syntax:
SELECT
COUNT(case_id) AS "Case Numbers", City AS "Site"
FROM THIS_PROCESS
ORDER BY 1 DESC


Query display: The total number of cases by city, displayed in a 
 widget and in a 
 widget.


Table:








Breakdown (bar chart):










Example 4: How many cases exist for New York and Miami?




Learning success: Filter a result set to include only records that fulfill a specified condition.


Query instruction: This query is very similar to example 3, but in this case, you do not query all cases but only the cases for New York and Miami. To filter the result, introduce the 
filter
 
keyword: WHERE
 and specify the 
filter condition
 
keyword: IN + expression: 'New York', 'Miami'
. 
Sort the result set by cities
 
keyword: ORDER BY 1
, in 
descending order
keyword: DESC
.


 syntax:
SELECT
COUNT(case_id) AS "Case Numbers", "City" AS "Site"
FROM THIS_PROCESS
WHERE City IN('New York', 'Miami')
ORDER BY 1 DESC


Query display: The total number of cases by filtered cities, displayed in a 
 widget and in a 
 widget.


Table:








Breakdown (bar chart):











﻿






 tutorial










 tutorial




This tutorial supports you to get started with 
.


Based on a sample process with test data, this tutorial introduces you to the main principles of 
, starting from simple case-attribute based queries to more complex event-based queries.


The tutorial is structured as follows:



Section | Examples | Learning success | Introduced keywords
Count cases and cities | - 
How many cases exist for this process?


- 
How many different cities are involved in this process?


- 
How many cases exist for each city?


- 
How many cases exist for New York and Miami? | - 
Count a case attribute


- 
Count the distinct records of a case attribute


- 
Count two or more case attributes


- 
Rename case attribute names with alias names


- 
Sort the result set


- 
Filter a result set to include only records that fulfill a specified condition | COUNT
COUNT DISTINCT
AS
ORDER BY
WHERE
IN
Analyze order amounts | - 
What is the average order amount of this process?


- 
What is the average order amount in Houston?


- 
What is the total order amount in Boston?


- 
What is the percentage order amount in Boston compared to the total order amount? | - 
Determine the average value of a case attribute


- 
Determine a filtered average case attribute


- 
Sum up a case attribute


- 
Determine the percentage value of a case attribute compared to the overall value


- 
Apply filter condition(s) within a query | AVG
SUM
FILTER
Determine process cycle times | - 
How long is the average cycle time of all cases?


- 
How long is the average cycle time by city?


- 
What are the maximum / minimum cycle times by city? | - 
Calculate cycle times


- 
Perform subqueries on event attributes


- 
Determine cycle time by case attribute


- 
Calculate the largest / smallest values | MAX
MIN
Investigate events | - 
How many cases have been closed / canceled?


- 
What is the drop-out rate?


- 
How many cases follow the standard process?


- 
How many cases are canceled although the T-shirts have been sent for printing? | - 
Counting the total number of events


- 
Filter for not true conditions


- 
Determine the process conformance | IF
NOT
MATCHES



 





﻿
















FROM clause




The FROM clause  specifies the table in your process from which you want to retrieve the data. 


THIS_PROCESS
 is the alias or temporary name assigned to the table that was set as default view in your process.  By default, the FROM clause fetches data from the default view.


Syntax
:
FROM table



Parameter | Description
table | The process table or view from which you want to retrieve records. You can reference the process by using the explicit Process ID which can be found on the API tab in the process settings page. Alternatively you can use the alias THIS_PROCESS to refer to the default view.



Example
: Get list of unique cities from default view


To retrieve the list of unique cities available in your process, run the following query.
SELECT DISTINCT city
FROM THIS_PROCESS


The query returns the following result.











﻿
















FILL clause




The FILL clause is used to fill results with values according to the fill specification.


Syntax
:
SELECT expression
FROM table
GROUP BY index 1...n
FILL specification 	



Parameter | Description
expression | The columns or calculations that you want to retrieve.
table | The process table or view from which you want to retrieve records, referenced by explicit Process ID or the alias THIS_PROCESS.
specification | The fill specification for each of the selected expressions in the same order that those expressions appear after SELECT.
TIMESERIES(date_part): Fills gaps in the result set for a timeseries with NULL according to the expression. The precision level (date_part) is given in single quotes for the timeseries gaps:
Available values:

- 
year


- 
quarter


- 
month


- 
week (ISO 8601-week numbering is applied)


- 
day


- 
hour



GROUP: Fills any grouping expressions (the ones referenced in the GROUP BY) by repeating the same value each time a timestamp is added inside this group.
NULL: Fills all results with NULL. No further expression required.
The TIMESERIES specification is required. Specifications can be omitted at the end and then default to NULL, but if the first expression is an aggregation for example, then NULL has to be specified.



Example
:
SELECT DATE_TRUNC('month', (SELECT FIRST(end_time)))AS"Date", "City", COUNT(case_id)AS"No.of Case IDs"
FROM THIS_PROCESS
ORDER BY 2,1
FILL TIMESERIES('month'), GROUP, NULL


This query fills the gaps in the timeseries for the selected duration of time. The query returns the following result.











﻿


















SAP Signavio Analytics Language




 
 Analytics Language, 
 is a specialized query language for process analysis.


The language is based on SQL. Like SQL, you use queries to retrieve data and perform calculations on the data. However, it is not possible to change or delete process data.


The difference to SQL is the data model. While you usually query data from multiple tables with SQL, 
 queries the data from only one table, which contains nested events. In addition, 
 provides numerous custom functions to work more effectively with this data structure.


 is optimized for process mining, for example to determine conformance, cycle times, and rework, and it supports exploration at scale by all kind of 
 users.


With 
, you can only retrieve data from processes to which you have access.




Data model




When mining the data of a process, you retrieve the data of a single table. This table contains the case attributes and their nested events and event attributes. The following table shows this nested structure.



case_ID | Customer ID | Status | City | events
1001 | 2001 | delivered | Berlin | event_name
end_time
Payment method
Cancellation reason




Receive customer order
2020-07-01T09:00:00
 
 


Receive payment
2020-07-02T10:00:00
Bank transfer
 


Ship goods
2020-07-03T11:00:00 | event_name | end_time | Payment method | Cancellation reason | Receive customer order | 2020-07-01T09:00:00 |  |  | Receive payment | 2020-07-02T10:00:00 | Bank transfer |  | Ship goods | 2020-07-03T11:00:00 |  | 
event_name | end_time | Payment method | Cancellation reason
Receive customer order | 2020-07-01T09:00:00 |  | 
Receive payment | 2020-07-02T10:00:00 | Bank transfer | 
Ship goods | 2020-07-03T11:00:00 |  | 
1002 | 2002 | canceled |  | event_name
end_time
Payment method
Cancellation reason




Receive customer order
2020-07-04T13:00:00
 
 


Cancel order
2020-07-04T14:00:00
 
Wrong size | event_name | end_time | Payment method | Cancellation reason | Receive customer order | 2020-07-04T13:00:00 |  |  | Cancel order | 2020-07-04T14:00:00 |  | Wrong size
event_name | end_time | Payment method | Cancellation reason
Receive customer order | 2020-07-04T13:00:00 |  | 
Cancel order | 2020-07-04T14:00:00 |  | Wrong size



The columns 
case_id
, 
event_name
 and 
end_time
 are always present. Case attributes like 
Customer ID
 , 
Status
, and 
City
 have the same value throughout the case. Additional event attributes, in this example 
Payment method
 and 
Cancellation reason
 can have different values for each event.


There are two ways to iterate over this data:




- 
per case
Each case is treated as one row. The nested events and event attributes are represented as a nested table.




- 
per event
Each event is treated as one row. The case ID and case attributes are repeated for each event.








Data types




The data type of a column defines which value the column can hold. All data types can occur on case level as well as on event level (nested). 


 supports the following data types:




- 
Strings




- 
Numbers stored as double precision floating point




- 
Timestamps stored with millisecond precision, without time zone information.




- 
Durations stored with millisecond precision




- 
Booleans






All of these data types can appear in the source file and in the query result.


Both case and event attributes can be Null, indicating  the absence of a value or an unknown value.




Process mining




 queries are used in the widgets of an investigation.


When configuring widgets, you have the following options:




- 
Create you own queries




- 
Use the default queries in the widgets and customize them if necessary




- 
Use the predefined queries from the metrics library and customize them if necessary




- 
Add your own queries to the metrics library for reuse






Read more on the widgets in section 
Widgets
.





﻿














Determine case cycle times




You want to determine the cycle times of your process: How long is the average cycle time of all cases? How long is the average cycle time by city? What are the maximum / minimum cycle times by city?




Example 1: How long is the average cycle time of all cases?




Learning success:




- 
Calculate cycle times




- 
Perform subqueries on event attributes






Query instruction: You have to calculate the cycle times first and then aggregate them to an average value. The cycle times are calculated from the event-based timestamps, so you have to perform a 
subquery
 
keyword: (SELECT
.


To calculate the cycle time, you have to 
subtract the first event timestamp
 
keyword: SELECT FIRST + expression: end_time
 from the 
last event timestamp
 
keyword: SELECT LAST + expression: end_time
. From these values, you 
aggregate the average value
 
keyword: AVG
 .


 syntax:
SELECT
AVG(
(SELECT LAST(end_time))
-
(SELECT FIRST(end_time)))
FROM THIS_PROCESS


Query result: The average cycle time, displayed in a 
 widget:










Example 2: How long is the average cycle time by city?




Learning success: Determine cycle time by case attribute.


Query instruction: Determine the average cycle time (see example 1) by 
city
 
expression: City
. Rename the case attribute with an 
alias
 
keyword: AS
 to "Cycle Time".


 syntax:
SELECT
AVG(
(SELECT LAST(end_time))
-
(SELECT FIRST(end_time))) AS "Cycle Time", "City"
FROM THIS_PROCESS


Query result: The average cycle times by city, displayed in a 
 widget:










Example 3: What are the maximum / minimum cycle times by city?




Learning success: Calculate the largest / smallest values.


Query instruction: According to example 1, you calculate the cycle times by city. From these values, you 
determine the smallest value
keyword: MIN
 and the 
largest values
keyword: MAX
. Rename the values with 
aliases
 
keyword: AS
 to "Maximum Cycle Time" and "Minimum Cycle Time". Finally 
sort the result set by city
keywords: ORDER BY 3
 in 
ascending order
keyword: ASC
.


 syntax:
SELECT
MAX(
(SELECT LAST(end_time))
-
(SELECT FIRST(end_time))) AS "Maximum Cycle Time",
MIN(
SELECT LAST(end_time))
-
(SELECT FIRST(end_time))) AS "Minimum Cycle Time",
"City"
FROM THIS_PROCESS
ORDER BY 3 ASC


Query result: The maximum /minimum cycle times, displayed in a 
 widget:











﻿


















 keywords





            This reference contains the keywords used in 
.


If an attribute is named like a keyword, the attribute must be enclosed in double quotes.



Keyword | Description
AND | Logical operator
ANY | Wildcard operator for MATCHES
AS | Function to rename the result set with an alias
ASC | Sorts the result set in ascending order
AVG | Function to determine the average of multiple values
BEHAVIOUR | Operator to check whether an expression matches a complex pattern. Used in conjunction with MATCHES.
BOOL_AND | Function that returns a value if all conditions are true
BOOL_OR | Function that returns a value if at least one condition is true
CASE WHEN | An expression which evaluates a list of conditions and returns a value when the conditions are met.
COUNT | Function to determine the number of records
COUNT DISTINCT | Function to determine the number of distinct records
CREATE | Reserved keyword
DATE_TRUNC | Date function to truncate timestamps
DESC | Sorts the result set in descending order
DROP | Reserved keyword
DURATION | Date function to specify a duration
EXTERNAL | Reserved keyword
FILL NULL | Function to fill all results with NULL
FILL GROUP | Function to fill groups with distinct values
FILL TIMESERIES | Function to fill gaps in the result set for a timeseries with NULL values
FILTER | Filters values inside of an expression
FIRST | Function to return the first value of an array
FORMAT | Reserved keyword
FROM | Specifies from where to retrieve the data
GRANT | Reserved keyword
GROUP BY | Function to group multiple values
HAVING | Reserved keyword
IF | Function to specify a condition
IN | Filter function
IS NOT NULL | Operator for NULL values
IS NULL | Operator for NULL values
LAST | Function to return the last value of an array
LIMIT | Function to limit the number of records in the result set
LOCATION | Reserved keyword
MATCHES | Operator to check whether an expression matches a simple pattern
MAX | Aggregate function to determine the maximum value
MIN | Aggregate function to determine the minimum value
NOT IN | Logical predicate to test the existence of a value
NULL | A field with a NULL value is a field with no value
OFFSET | Starting point to return rows from a result set.
ONLY | Reserved keyword
OR | Logical operator
ORDER BY | Function to sort the result set according to sorting criteria
PARQUET | Reserved keyword
PERMISSIONS | Reserved keyword
PUBLIC | Reserved keyword
PRIVATE | Reserved keyword
REPLACE | Reserved keyword
SELECT | Selects data from the table.
SUM | Function to sum up the values of the result set
TABLE | Reserved keyword
TO | Reserved keyword
UNION ALL | Combines the result set of two or more SELECT statements
WHERE | Filters a result set to include only records that fulfill a specified condition
WITH | Reserved keyword






﻿
















OFFSET clause




With the OFFSET clause, you can specify the starting point to return rows from a result set.


Syntax
:
SELECT expression
FROM table
LIMIT number
OFFSET offset_number



Parameter | Description
expression | The column or expression that you want to retrieve.
table | The process table or view from which you want to retrieve records, referenced by explicit Process ID or the alias THIS_PROCESS
number | The number of rows in the result set.
offset_number | The amount or rows to skip from the top of the table.



For the OFFSET to provide consistent results, you need to add ORDER BY clause in the query.


Example
: OFFSET clause with ORDER BY and LIMIT clauses
SELECT case_id AS "Case ID", "Order Amount", "Customer ID"
FROM THIS_PROCESS
ORDER BY 2 DESC
LIMIT 5
OFFSET 10



This query returns the discounts in row 11 to 16.











﻿
















WHERE clause




The WHERE clause is used to filter the data and apply conditions to the SELECT statement. This lets you retrieve subsets of table rows based on set conditions.


Syntax
:
WHERE condition



Parameter | Description
condition | The condition that must be met for records you want to select.



Following are the common symbols used in WHERE clause:



Symbols
> (greater than)
< (less than)
>= (greater than or equal to)
<= (less than or equal to)
= (equal to)
!= (not equal to)



Example 1
: Get the total purchase order amount


To retrieve the total order amount from the purchases made in the Boston city. This query retrieves the  Order Amount column values that match the WHERE condition.
SELECT SUM("ORDER AMOUNT")
FROM THIS_PROCESS
WHERE("City"='Boston')


This query returns the total order amount in Boston as 94,757.15.


Example
 2: Using AND in the WHERE clause


To get the list of case Ids of the orders from Miami city with order status as delivered, run the following query.
SELECT case_id,"City", "Order Status"
FROM THIS_PROCESS
WHERE("ORDER Status"='Delivered' AND "City"='Miami')


The query returns the following result.











﻿














Understand the sample process




This tutorial is using the following sample process:










For a more detailed view of the process flow, check the 
Process Discovery
 widget of the sample process.




In this tutorial, the following case and event attributes are used:




- 
Case attributes


Case ID


City


Order Amount in EUR






- 
Event attributes


EventName


Timestamp








Example (extract):










For more detailed information about the test data, check them under 
Process Settings > Data
 in the sample process.







﻿


















Arithmetic Expressions




Use the arithmetic expressions to execute mathematical operations with numeric values.


The following arithmetic operators are available:



Operator | Description
+ | Add
– | Subtract
* | Multiply
/ | Divide
% | Modulo





Syntax





 | Type information
expression1 + expression2 | Number
+
Number
=
Number


Timestamp
+
Duration
=
Timestamp


Duration
+
Timestamp
=
Timestamp


Duration
+
Duration
=
Duration | Number | + | Number | = | Number | Timestamp | + | Duration | = | Timestamp | Duration | + | Timestamp | = | Timestamp | Duration | + | Duration | = | Duration
Number | + | Number | = | Number
Timestamp | + | Duration | = | Timestamp
Duration | + | Timestamp | = | Timestamp
Duration | + | Duration | = | Duration
expression1 - expression2 | Number
–
Number
=
Number


Timestamp
–
Timestamp
=
Duration


Timestamp
–
Duration
=
Timestamp


Duration
–
Duration
=
Duration | Number | – | Number | = | Number | Timestamp | – | Timestamp | = | Duration | Timestamp | – | Duration | = | Timestamp | Duration | – | Duration | = | Duration
Number | – | Number | = | Number
Timestamp | – | Timestamp | = | Duration
Timestamp | – | Duration | = | Timestamp
Duration | – | Duration | = | Duration
expression1 * expression2 | Number
*
Number
=
Number


Number
*
Duration
=
Duration


Duration
*
Number
=
Duration | Number | * | Number | = | Number | Number | * | Duration | = | Duration | Duration | * | Number | = | Duration
Number | * | Number | = | Number
Number | * | Duration | = | Duration
Duration | * | Number | = | Duration
expression1 / expression2 | Number
/
Number
=
Number


Duration
/
Number
=
Duration


Duration
/
Duration
=
Number | Number | / | Number | = | Number | Duration | / | Number | = | Duration | Duration | / | Duration | = | Number
Number | / | Number | = | Number
Duration | / | Number | = | Duration
Duration | / | Duration | = | Number
expression1 % expression2 | Number
%
Number
=
Number | Number | % | Number | = | Number
Number | % | Number | = | Number





Operator Precedence




These operators follow the standard mathematical order of operations. This means:




- 
Evaluation proceeds from left to right. For example, 9 - 5 + 2 is interpreted as (9 - 5) + 2 = 6 rather than 9 - (5 + 2) = 2.




- 
Evaluation is performed in order of precedence (from higher to lower). For example, 5 + 2 * 2 is interpreted as 5 + (2 * 2) = 9 rather than (5 + 2) * 2 = 14.








Examples






Example 1




This query subtracts the order quantity from the shipment quantity, calculating any difference between an order's size and the total number of goods actually dispatched.

```
SELECT case_id, (SELECT SUM("Shipment Quantity")) - "Order Quantity" AS DiffFROM THIS_PROCESS
```



Result (canceled orders, where no delivery took place, have no number displayed):










Example 2




This query divides each payment received by the total amount of the order and multiplies by 100. The resulting figure is the percentage of the full amount each individual payment represents.



```
SELECT case_id, "Payment Amount" / "Order Amount" * 100 AS "Proportion %"FROM FLATTEN(THIS_PROCESS)WHERE event_name = 'Receive Payment'
```





Result:










Example 3




This query returns the remainder when dividing the shipment quantity by 15. Assuming goods from an order are shipped in containers with a capacity of 15, this query calculates how many units were shipped in a non-full container.



```
SELECT "Shipment Quantity" % 15 AS "Units shipped in non-full container"FROM FLATTEN(THIS_PROCESS)WHERE ("Shipment Quantity" IS NOT NULL)
```





Result:











﻿
















SELECT DISTINCT clause




The SELECT DISTINCT clause returns unique values of a specified column. If NULL values are present, they are included. This function is not supported in subqueries.


Syntax
:
SELECT DISTINCT expression
FROM table



Parameter | Description
expression | The column, expression, or event-attribute that is returned. If more than one expression is provided, separate the values with a comma.
table | The process table or view from which you want to retrieve data. It is referenced by explicit Process ID or the alias THIS_PROCESS.



Example 1
: Get unique cities in your process
SELECT DISTINCT city
FROM THIS_PROCESS
ORDER BY 1 ASC


This query returns all unique city names from the city column in the default process view, sorted in ascending order. Duplicate values are removed from the result set. Therefore every city name appears only once.








Example 2
: Get unique event name sequences (variants) in your process
SELECT DISTINCT event_name AS "Event Name:"
FROM THIS_PROCESS


This query returns all unique event name sequences (also referred to as variants) from the event name column in the default process view. Using AS “Event Name:” assigns a column alias to the result. The query is executed at the case level which means that the event name sequences are represented as nested lists of event names. Duplicate values are removed from the result set so that every event name sequence (nested list) only appears once.








Example 3
: Get only unique  event names in your process
SELECT DISTINCT event_name AS "Event Name:"
FROM FLATTEN (THIS_PROCESS)
ORDER BY 1 ASC


This query returns a unique list of event names in ascending order. Using AS “Event Name:” assigns a column alias to the result. Using the FLATTEN expression flattens the nested event data in the process, thereby representing each nested event as a single row containing case and event properties. Duplicate values are then removed from the result set so that every event name only appears once.











﻿
















Window Sort Order




The ORDER BY clause sorts the data set in the PARTITION BY clause in ascending or descending order.




Syntax


SELECT column name, SUM(column name) OVER (ORDER BY column name ASC)



Parameter | Description
column name | The column name in your table you want to include in the function.





Example




Consider the following table:



City | Value
Berlin | 1000
Paris | 3000
London | 2500
Rome | 1500

SELECT city, SUM(value) OVER (ORDER BY value ASC)


This query returns the cumulative sum:



City | Value
Berlin | 1000
Rome | 2500
London | 5000
Paris | 8000






﻿














 functions




In this section, it is explained which functions you can use in 
 queries. The following functions are available:




- 

Aggregate functions





- 

Arithmetic functions





- 

Date functions





- 

Window functions





- 

BUCKET() function










﻿












Analyze order amounts




You want to get insights about the order amount: What is the average order amount of this process? What is the average order amount in Houston? What is the total order amount in Boston? What is the order amount in Boston related to the total order amount?




Example 1: What is the average order amount of this process?




Learning success: Determine the average value of a case attribute.


Query instruction: 
Determine the average value
 
keyword: AVG
 for the 
order amount
expression: Order Amount in EUR
.


 syntax:
SELECT 
AVG("Order Amount in EUR")
FROM THIS_PROCESS


Query result: The aggregated value, displayed in a 
 widget:










Example 2: What is the average order amount in Houston?




Learning success: Determine a filtered average case attribute.


Query instruction: Determine the average order amount (see example 1). 
Introduce the filter
 
keyword: WHERE
 and 
specify the filter condition
 
expression: "City"='Houston'
.


 syntax:
SELECT 
AVG("Order Amount in EUR")
FROM THIS_PROCESS
WHERE("City"='Houston')


Query result: The average order amount in Houston, displayed in 
 widget:










Example 3: What is the total order amount in Boston?




Learning success: Sum up a case attribute.


Query instruction: 
Sum up
 
keyword: SUM
 the 
total order amount
 
expression: "Order Amount in EUR"
. 
Introduce the filter
 
keyword: WHERE
 and 
specify the filter condition
 
expression: "City"='Boston'
.


 syntax:
SELECT 
SUM("Order Amount in EUR")
FROM THIS_PROCESS
WHERE("City"='Boston')


Query result: The total order amount in Boston, displayed in a 
 widget:










Example 4: What is the percentage order amount in Boston compared to the total order amount?




Learning success:




- 
Determine the percentage value of a case attribute compared to the overall value.




- 
Apply filter condition(s) within a query.






Query instruction: Sum up the order amount in Boston (see example 3). Unlike example 3, you cannot apply the filter condition as the last step. You have to 
filter
 
keyword: FILTER + filter condition: (WHERE "City"='Boston')
 the result set before you can calculate the percentage value.


 syntax:
SELECT 
SUM("Order Amount in EUR")
FILTER (WHERE "City"='Boston')
/SUM("Order Amount in EUR")
* 100
FROM THIS_PROCESS


Query result: The percentage order amount of Boston, displayed in a 
 widget:











﻿














Window functions




This section explains the window functions that you can use in your 
 queries.


Window functions are aggregate-like functions that you can perform over a selection of the rows which are selected by a query. You can use window functions to perform calculations on a set of table rows that are related to the current row in a table. In window functions, each row remains separate to the query output. Window functions have access to all the rows that are part of the current row's group which is determined by the PARTITION BY list of the window function.


Below is the general form of a window function:
{aggregation function} OVER ([PARTITION BY {partition expressions}] [ORDER BY {order expressions}] [[ROWS | RANGE] BETWEEN {window frame}])




- 
The {aggregation function} is the function which groups the values of multiple rows to create a single summary value.




- 
The ORDER BY clause sorts the data set in the PARTITION BY clause in ascending or descending order.




- 
The PARTITION BY clause is a subclause of the OVER clause and groups a data set into partitions.




- 
ROWS|RANGE modes define the scope of the {window frame}.




- 
The {window frame} is the set of rows related to the current row where the window function is used to calculate the values of the defined window. You can define the window frame by using the ROW and RANGE modes.








Limitations




Below is a list of current limitations that apply while using window functions in 
 queries:




- 
Window functions can only be used on  flat data, not on event level or nested data.




- 
You can't create an empty window frame when using window functions. The following are examples of empty window frames:


ROWS BETWEEN 1 PRECEDING AND 2 PRECEDING


ROWS BETWEEN 1 FOLLOWING AND 1 PRECEDING


ROWS BETWEEN 1 FOLLOWING AND CURRENT ROW










Considerations




Below is a list of considerations when using window functions in 
 queries:




- 
Window functions are evaluated after aggregate functions in a SELECT clause.




- 
Window functions can only occur in SELECT clauses and on flat data. Nested data structures aren’t supported. If you have a nested data structure like an event log, you can use window functions on case level. If you want to use window functions on event level you can use the FLATTEN operator to create a flat table and then use PARTITION BY case_id.




- 
In ORDER BY clauses, only use expressions such as column names and not numeric values for indices.








Functions




In window functions you can use aggregate and non-aggregate functions. 




Aggregate functions




 You can use the following aggregate functions:




- 
SUM




- 
COUNT




- 
MIN




- 
MAX




- 
AVG




- 
FIRST




- 
LAST




- 
BOOL_OR




- 
BOOL_AND






For more information, see 
Aggregate functions
.




Non-aggregate functions




You can use the following non-aggregate functions:




- 
LAG




- 
LEAD




- 
ROW_NUMBER






For more information, see 
Non-aggregate functions
.





﻿


















LIKE and ILIKE expressions




Using LIKE and ILIKE expressions, you can search for a specified string pattern in a column with 
string
 data type. The LIKE expression matches case-sensitive string patterns, whereas the ILIKE expression matches case-insensitive string patterns. 


Both of these expressions provide:




- 
flexible string comparison using special characters




- 
improved string filtering and bucketing




- 
flexible process variant filtering using MATCHES and BEHAVIOR MATCHES expressions






An optional keyword 'NOT' can be used along with LIKE and ILIKE expressions to search for the non-matching string patterns.




Syntax


expression [NOT] LIKE pattern
expression [NOT] ILIKE pattern



Parameter | Description
expression | The string expression that is compared with the defined pattern.
pattern | The defined string pattern the expression is compared with.
The string pattern includes special characters percent (%) and underscore (_) to conduct a character-by-character comparison.
NOT | An optional keyword that is used to negate the expression matching.



The LIKE and ILIKE expressions take 
string
 as input and return 
boolean
 as output.


For example:



Expression | Output
‘Amsterdam' LIKE 'A%' | true
'Ibiza' ILIKE '%A' | true
‘Boston' NOT LIKE 'B%' | false
'Miami' NOT ILIKE '%I' | false





Special characters




The LIKE and ILIKE expressions use special characters to compare strings, character-by-character. 


The following special characters can be used in conjunction with these expressions:





- 
	 The percent (%) wildcard represents zero, one, or multiple characters




- 
 The underscore (_) wildcard represents one, single character




- 
The backslash (\) character represents the escape character






You can also combine these special characters in a pattern.



Special characters usage | Description
ILIKE '%to%' | Returns true if the matching string pattern contains "to" in any case and in any position
Example: "Washington", "Boston", "Paolo Alto", "Stockton"
LIKE '_o%' | Returns true if the matching string pattern contains "o" in the second position

Example: "Boston", "Rostock"
ILIKE 'm__%' | Returns true if the matching string pattern starts with "m" or "M" and is at least 3 characters in length

Example: "Miami", "Munich"
ILIKE 'b%n' | Returns true if the matching string pattern starts with "b" or "B", and ends with "n" or "N"
Example: "Berlin", "bern", "Boston"





LIKE and ILIKE expressions with MATCHES




You can also use the LIKE and ILIKE expressions with MATCHES and BEHAVIOR MATCHES expressions for filtering nested data. For example,  see 
Example 3
 and 
Example 4
.




Examples






Example 1




The following example displays the use of wildcards in the string pattern.
SELECT "Type of Goods", count("Type of Goods") 
FROM FLATTEN(THIS_PROCESS)
WHERE "Type of Goods" ILIKE '%with print'
ORDER BY 1



Result:


The query collects the “Type of Goods” that ends with the value 'with print'.










Example 2




The following example displays the use of escape character (\) in the string pattern.
SELECT "Type of Goods", case_id
FROM THIS_PROCESS
WHERE case_id LIKE “100\\%”
GROUP BY 1



Result:


The query returns the entries where the case_id value starts with 100, follows by a backslash character, and ends with any characters or numbers in a 
 table.










Example 3




The following example displays the use of ILIKE expression in MATCHES expression.
SELECT count(case_id)
FROM THIS_PROCESS
WHERE event_name MATCHES ('Receive Customer Order' ~> ILIKE '%print%' ~> ILIKE '%ship%')



Result:


The query returns the count of case_ids from THIS_PROCESS where a print action occured, and where the order was shipped either as standard or express.










Example 4




The following example displays the use of ILIKE expression in BEHAVIOR MATCHES expression.
SELECT count(case_id)
FROM THIS_PROCESS
WHERE 
BEHAVIOR 
(event_name == 'Receive Customer Order') as order_received,
(event_name ILIKE '%print%') as order_printed,
(event_ILIKE '%ship%') as order_shipped
MATCHES (order_received ~> order_printed ~> order_shipped)



Result:


The query returns the count of case_ids from THIS_PROCESS where a print action occured, and where the order was shipped either as standard or express.










Example 5




The following example displays the use of NOT LIKE expression.
SELECT DISTINCT(event_name)
FROM FLATTEN(THIS_PROCESS)
WHERE event_name NOT LIKE '%Purchase%'


Result:


The query selects the event_name from THIS_PROCESS where the event_name does not contain the string 'Purchase'.











﻿
















GROUP BY clause




The GROUP BY clause is used to group the result of a SELECT statement by the expressions at the specified indices. For example, 
GROUP BY 1, 2
 groups the result by the first and second expression. All rows that share the same values for the grouped expressions are condensed into a single row.


The GROUP BY clause is often used with aggregate functions, for example COUNT, MAX, MIN, and AVG. Read more in section 
Aggregate functions
. An aggregate function is computed across all rows of each group and returns a separate value for each group.


The GROUP BY clause is optional. If the GROUP BY clause is not present, then the following applies:




- 
If there are aggregate and non-aggregate expressions in the SELECT statement, then the result is automatically grouped by any non-aggregate expressions. 




- 
If there are only aggregate expressions in the SELECT statement, then the result is a single group comprising all the selected rows.






To specify the rows to be considered for the aggregation, you can apply the FILTER clause to the aggregate function.


If the GROUP BY clause is present, then the following applies:




- 
You must group by all expressions in the SELECT statement that are not encapsulated by an aggregate function. Exception: The ungrouped expression is functionally dependent from a grouped expression (see example 2 below).




- 
You can't group by an expression that contains an aggregate function.






Syntax:
SELECT expression1, expression2, ... expression_n,
aggregate_function (aggregate_expression)
FROM table
GROUP BY index [, ...]



Parameter | Description
index [, ...] | The 1-based indexing of the expressions in the SELECT clause that are not encapsulated within an aggregate function.
The expression relates either to a case-level attribute, for example "city", or to an event-level attribute, for example "event-name". In the first case, the result is grouped by cities. In the second case, the result is grouped by the list of identical sequences of events. This can be used to identify process variants.
aggregate_function | An aggregate function such as the SUM, COUNT, MIN, MAX, or AVG function.
aggregate_expression | The column or expression that the aggregate function is used on.
table | The process table or view from which you want to retrieve records, referenced by explicit Process ID or the alias THIS_PROCESS.



Example 1
: Case with GROUP BY on multiple columns
SELECT city, region, COUNT(case_id)
FROM THIS_PROCESS
GROUP BY 1, 2


GROUP BY 1, 2
 groups by the expressions in the SELECT statement which are not encapsulated by an aggregation function. Since this SELECT statement contains two expressions (
city
 and 
region
), the 
GROUP BY
 index must refer to both expressions. 
GROUP BY 1
 or 
GROUP BY 2
 is not valid in this case.


Example 2
: Case with GROUP BY


To get the count of case ids with actual order amounts and order amounts multiplied 2.50 times, run the following query.
SELECT "Order Amount", ("Order Amount"*2.50) AS "Orders", COUNT(case_id) AS "No.of Cases"
FROM THIS_PROCESS
GROUP BY 1, 2


Since the second expression 
order_amount*2.50
 is functionally dependent to the first colum 
order_amount
, 
GROUP BY 1
 is valid in this case.


The query returns the following result.











﻿














 expressions and functions




In this section, it is explained which expressions and functions you can use in SIGNAL queries. 


The following expressions are available:




- 

Arithmetic expressions





- 

Comparison expressions





- 

Logical expressions





- 

Matching expressions





- 

LIKE and ILIKE expressions





- 

CASE WHEN expression





- 

Expressions for NULL values







The following functions can be used in SIGNAL queries:




- 

Aggregate functions





- 

Arithmetic functions





- 

Date functions





- 

Window functions





- 

BUCKET() function







 





﻿














Investigate events




You want to get an overview about the events of the process: How many cases have been closed / canceled? What is the drop-out rate? How many cases follow the standard process? How many cases are canceled although the T-shirt has been sent for printing?




Example 1: How many cases have been closed / canceled?




Learning success: Counting the total number of events.


You perform two subqueries for the last event names and sum up all cases for which the respective condition is fulfilled. The event names are event-based attributes, so you perform a 
subquery
 
keyword: (SELECT
.






Select the last events of the cases
 
keyword: SELECT LAST + expression: event_name
.






If
 
keyword: IF
 the 
last event name is "Receive Delivery Confirmation"
 
keyword: IN + expression: ('Receive Delivery Confirmation')
 
count 1, otherwise 0
 
keyword: 1,0)
. 
Sum up
 
keyword: SUM
 the value for all cases. 
Rename the value with an alias
keyword: AS
 to "Closed Cases".


To count the value for the canceled cases, 
reverse the count condition
 
keyword: 0,1
. Rename the column header with an 
alias
 
keyword: AS
 to "Canceled Cases".


 syntax:
SELECT
SUM
(IF
((SELECT LAST("event_name"))
IN('Receive Delivery Confirmation'),1,0)) AS "Closed Cases",
SUM
(IF
((SELECT LAST("event_name"))
IN('Receive Delivery Confirmation'),0,1)) AS "Canceled Cases"
FROM THIS_PROCESS


Query result: The total number of closed and canceled cases, displayed in a 
 widget:










Example 2: What is the drop-out rate?




Learning success: Filter for not true conditions.


Query instruction: 
Select the last events of the cases
 
keyword: SELECT LAST + expression: event_name
. 
Filter the result set
keyword: FILTER (WHERE
 for event names 
other than
 
keyword: NOT
 
"Receive Delivery Confirmation"
 
keyword: IN+ expression: ('Receive Delivery Confirmation')
 and calculate the percentage.


 syntax:
SELECT
(COUNT(case_id) FILTER
(WHERE NOT(SELECT LAST(event_name)
IN('Receive Delivery Confirmation'))))
/
COUNT(case_id)
*100
FROM THIS_PROCESS


Query results: The drop-out rate, displayed in a 
Value
 widget:










Example 3: How many cases follow the standard process?




Learning success: Determine the process conformance.


Query instruction: This query is similar to example 2, but in this case, you do not only search for the first or last event but for a certain pattern of events.


You query the following pattern:




1. 
The starting event is "Receive Customer Order" expression: ^'Receive Customer Order'




2. 
The next event (directly or indirectly following the start event) is "Receive Payment" expression: ~> 'Receive Payment'.




3. 
The next event (directly or indirectly following the preceding event) is either "Ship Goods Standard" or "Ship Goods Express"expression: ~>('Ship Goods Standard | 'Ship Goods Express') .




4. 
The final event (directly or indirectly following the preceding event) is "Receive Delivery Confirmation" expression: 'Receive Delivery Confirmation'$.






For the conformance to this pattern, you calculate the percentage.


 syntax:

SELECT
(COUNT(case_id) FILTER
(WHERE event_name MATCHES
(^ 'Receive Customer Order'
~>'Receive Payment'
~>('Ship Goods Standard'|'Ship Goods Express')
~> 'Receive Delivery Confirmation'$)))
/
COUNT(case_id)
*100
FROM THIS_PROCESS
        


Query result: The pattern matching, displayed in a 
 widget.










Example 4: How many cases are canceled although T-shirt has been sent for printing?




Learning success: Determine the process conformance.


Query instruction: This query is similar to example 3, but for a different type of pattern: You want to determine how many orders have been canceled while the T-Shirt has already been sent for printing.


You query the following pattern:




1. 
The starting event is "Receive Customer Order"expression: ^'Receive Customer Order'




2. 
The next event (directly or indirectly following the start event) is "Receive Payment"expression: ~> 'Receive Payment'.




3. 
The next event (directly or indirectly following the preceding event) is "Send T-shirt to Printing"expression: ~>'Ship T-shirt to Printing' .




4. 
The final event (directly or indirectly following the preceding event) is "Order Canceled"expression: 'Order Canceled'$.






For the conformance to this pattern, you calculate the percentage.


 syntax:

SELECT
(COUNT(case_id) FILTER
(WHERE event_name MATCHES
(^ 'Receive Customer Order'
~>'Receive Payment'
~>'Send T-shirt to Printing')
~>'Order Canceled'$)))
/
COUNT(case_id)
*100
FROM THIS_PROCESS
        


Query result: The pattern matching, displayed in a 
 widget.











﻿
















String Functions




Use string functions to manipulate strings in queries.




CONCAT




Combines two strings into a single string value by concatenating them.


CONCAT can only be applied to non-nested attributes. To use CONCAT on nested attributes, use the FLATTEN operator. Alternatively, use a nested query that returns a single string attribute as a result.




Syntax



```
CONCAT(expression1, expression2)
```



Alternative syntax:
expression1
 || 
expression2



Parameter | Description | Valid Types
expression1 | An expression, literal or non-nested attribute. | String
expression2 | An expression, literal or non-nested attribute. | String



Returns:
 A String, the result of appending expression2 to expression1.




Example (Non-nested Attributes)




This query concatenates a dash to the name of every event which features the string 'ship'. It then uses the output of that call as a parameter to a second call to CONCAT, appending the carrier name.
SELECT
    COUNT(DISTINCT case_id) AS "Case Count", event_name,
    "Shipment Carrier",
    CONCAT(CONCAT(event_name, ' - '), "Shipment Carrier") AS "Shipment Type and Provider"
FROM FLATTEN(THIS_PROCESS)
WHERE event_name ILIKE '%ship%'


Output:










Example (Nested Attributes)




This query selects a field from a nested attribute, using a subquery to select the first event name. Using the alternate syntax for concatenation, it appends to this event name the case ID.
SELECT 
    case_id,
    (SELECT FIRST(event_name)) AS "Nested Attribute: Event_Name",
    (SELECT FIRST(event_name)) || case_id AS "Nested Attribute Adjustment: Event_Name+Case_Id"
FROM THIS_PROCESS



Output:










REPLACE




Searches a string, replacing all occurrences of a specified substring with an alternative string.


REPLACE can only be applied to non-nested attributes. To use REPLACE on nested attributes, use the FLATTEN operator. Alternatively, use a nested query that returns a single string attribute as a result.




Syntax



```
REPLACE(sourceExpression, searchExpression, replacementExpression)
```




Parameter | Description | Valid Types
sourceExpression | The string to be searched. An expression or non-nested attribute. | String
searchExpression | The substring to be replaced. An expression or literal value. | String
replacementExpression | The string which replaces the substring. An expression or literal value. | String



Returns:
 A String, the result of replacing in sourceExpression all incidences of searchExpression with replacementExpression.




Example (Non-nested Attributes)


SELECT 
    DISTINCT "Type of Goods",
    REPLACE("Type of Goods", 'Cappy', 'Cap') AS "Single Text Adjustment (Literal): Cappy->Cap",
    REPLACE("Type of Goods", 'w', 'W') AS "Multiple Text Adjustment (Literal): w->W"
FROM FLATTEN(THIS_PROCESS)


Output:










Example (Nested Attributes)


SELECT
    case_id,
    (SELECT FIRST(event_name)) AS "Nested Attribute: Event_Name",
    REPLACE((SELECT FIRST(event_name)), 'Customer','Cust') AS "Nested Attribute Adjustment: Customer->Cust"
FROM THIS_PROCESS


Output:













﻿


















 aliases





            Aliases are used to give the result set a temporary name to make the column headings in your result set easier to read. It's common to alias a column when using an aggregate function in a query. Without an alias, a name will be generated based on the column and operations in the expression. Read more in section 
 functions
.


An alias is only valid within the scope of the 
 statement.


Syntax:
expression AS alias_name



Parameter | Description | Required
expression | The expression that you want to give a better name. | Required
alias_name | The temporary name to assign.
Enclose the name in double quotes if it contains a character that isn't a letter or digit. | Required



Example:


In this example, we have the following data in a table:



case_id | event_name | end_time
1001 | Receive customer order | 2020-07-01T09:00:00
1002 | Receive customer order | 2020-07-04T13:00:00
1003 | Receive customer order | 2020-07-05T11:00:00



Enter the following 
 statement:
SELECT COUNT(case_id) AS "No. of cases"
FROM THIS_PROCESS


This query returns the following result set:



No. of cases
3






﻿
















ORDER BY clause




The ORDER BY clause is used to sort the result set in ascending or descending order, and add one or more sorting criteria.


Syntax
:
SELECT expression
FROM table
ORDER BY order_index [, ...] [ASC | DESC] [NULLS FIRST | NULLS LAST]



Parameter | Description
expression | The columns or calculations that you want to retrieve.
table | The process table or view from which you want to retrieve records, referenced by explicit Process ID or the alias THIS_PROCESS.
order index [, ...] | The 1-based index of a selected expression used to sort the records in the result set. If more than one expression is provided, separate the values with comma.
[ ASC | DESC ] [NULLS FIRST | NULLS LAST] | ASC sorts the result set in ascending order by order_expression, DESC sorts it in descending order.
NULLS FIRST | NULLS LAST sorts the result set in order by null values first or last in list, default to first.



Example
: Case with ORDER BY
SELECT case_ID AS "Case IDs", "Order Amount", "Customer Type"
FROM THIS_PROCESS
ORDER BY 2 DESC


This query returns cases in the process sorted by the order amount in descending order.











﻿
















Expressions for NULL values






IS NULL




The IS NULL expression is used to test for empty values (NULL values). It returns TRUE if a NULL value is found, otherwise it returns FALSE.




Syntax


SELECT expression
FROM table
WHERE expression IS NULL




Parameter | Description
expression | The expression to test for a NULL value.





Example




The following example returns the case IDs whose payment amount is null.
SELECT DISTINCT
	"case_id" AS "Case ID", 
	"Shipment Number", 
	"Shipment Carrier"
FROM FLATTEN(THIS_PROCESS) 
WHERE "SHIPMENT Number" IS NULL
LIMIT 10


Result:


The query returns the following result.










IS NOT NULL




The IS NOT NULL expression is used to test for non-empty values (NOT NULL values). It returns TRUE if a non-NULL value is found, otherwise it returns FALSE.




Syntax


SELECT expression
FROM table
WHERE expression IS NOT NULL




Parameter | Description
expression | The expression to test for a NOT NULL value.





Example




The following example returns the case IDs where the payment amount is  not null.
SELECT DISTINCT 
	"case_id" AS "Case ID", 
	"Shipment Number", 
       "Shipment Carrier"
FROM FLATTEN(THIS_PROCESS) 
WHERE "SHIPMENT Number" IS NOT NULL
LIMIT 10


Result:


The query returns the following result.








 





﻿
















Conditional expressions




This section provides you with the following conditional expressions:




- 

CASE WHEN expression





- 

IF expression









CASE WHEN expression




The CASE WHEN expression evaluates a list of conditions and returns a value when the first condition is met. Once a condition is true, it stops reading and returns the result. If no conditions are true, it returns the value in the ELSE clause. If the ELSE clause is not present, it returns a NULL value.


Each CASE statement must end with the END statement. The ELSE statement is optional, and provides a way to capture values not specified in the WHEN/THEN statements.


The WHEN statement is evaluated in the following ways:




- 

                   If a match is found, then the corresponding result in the THEN statement is returned, and the evaluation stops. Any further WHEN statements aren't evaluated.




- 
If no match is found and an ELSE statement is present in the expression, then the result in the ELSE statement is returned.




- 
If no match is found, and no ELSE statement is present, then a NULL value is returned.








Syntax


CASE
    WHEN condition 1 THEN result 1
    [WHEN condition 2 THEN result 2]
    [ELSE result 3]
END



Parameter | Description
Condition 1 | The first condition which compares column values and / or expressions and returns a boolean (TRUE or FALSE) result.
Result 1 | The first result which is returned if condition 1 evaluates to TRUE.
Condition 2 | The second condition which compares column values and/or expressions and returns a boolean (TRUE or FALSE) result.
Result 2 | The second result which is returned if condition 1 evaluates to FALSE and condition 2 evaluates to TRUE.
Result 3 | The third result that is used if no match is found in the previous conditions.



The CASE WHEN expression can be used in the following clauses:




- 
SELECT




- 
WHERE






The following comparison operators and keywords can be used in the WHEN clause:



Operator / Key words | Example
< | WHEN "Order Amount" < '1000' THEN 'Approved'
> | WHEN "Order Amount" > '1000' THEN 'Approved'
<= | WHEN "Order Amount" <= '1000' THEN 'Approved'
>= | WHEN "Order Amount" >= '1000' THEN 'Approved'
= | WHEN "Order Amount" = '1000' THEN 'Approved'
<> | WHEN "Order Amount" <> '1000' THEN 'Rejected'
IN | WHEN "Country" IN ('Germany', 'France') THEN 'Europe'
NOT IN | WHEN "Country" NOT IN ('Germany', 'France') THEN 'Rest of the World'





Examples






Example 1




The following example selects countries based on regions. When a country is in a specific region (condition is true), it's added to the region (result). If a country doesn't match any of the conditions, it's added to the  ELSE result  "Rest of World".
SELECT DISTINCT
     "Country",
    CASE WHEN "Country" = 'USA' THEN 'North America'
         WHEN "Country" = 'Germany' THEN 'EU'
         WHEN "Country" = 'France' THEN 'EU'
         WHEN "Country" = 'South Africa' THEN 'Africa'
         ELSE 'Rest of World'
         END AS "Region"
FROM THIS_PROCESS


Result:


The query returns which countries reside in which regions in a 
.










Example 2




The following example compares the minimum and maximum values of customer satisfaction ratings (CSAT) at an event level in a CASE WHEN expression. 

SELECT "Country",
CASE WHEN (SELECT(MAX("CSAT"))) = (SELECT(MIN("CSAT"))) THEN 'None'
     WHEN (SELECT(MAX("CSAT"))) - (SELECT(MIN("CSAT"))) <= 1 THEN 'Low'
     WHEN (SELECT(MAX("CSAT"))) - (SELECT(MIN("CSAT"))) <= 3 THEN 'Medium'
     ELSE 'High'
     END AS "CSAT Delta",
     count(case_id)
FROM THIS_PROCESS 
GROUP BY 1,2



Result:


The query returns the total number of cases in each CSAT Delta category (None, Low, Medium, and High) and Country. The CSAT Delta category is determined by the delta between the maximum CSAT and minimum CSAT value within the case.










IF expression




The IF expression evaluates a single condition and return values based on the defined parameters. You need to provide two parameters, one for true and one for false.




- 
If the condition evaluates to true, the expression returns the desired value. 




- 
If the condition evaluates to false, the expression returns a different value.






The values returned can be literals, column attributes or the results of other expressions, such as additional IF expressions.




Syntax


IF(condition, valueIfTrue, valueIfFalse)




Parameters





Parameter | Description
Condition | The condition to be evaluated.
valueIfTrue | The value to be returned if the condition is met. This value can be a literal, column attribute, result of an expression, or additional IF expression.
valueIfFalse | The value to be returned if the condition is not met. This value can be a literal, column attribute, result of an expression, or additional IF expression.





Nested IF




IF expressions that contain additional IF expressions as value_if_true or value_if_false are called nested IF expressions. Either or both of the possible return values, value_if_true and value_if_false, can be another IF expression. The number of nested IF expressions is limited to 256.




Examples




Following are the examples of simple IF and nested IF.




Example with simple IF




The following example returns a distinct list of cities along with an associated state. The IF expression is used to compare the City to a literal value 'San Francisco'. If the City name matches the defined condition, the state value is returned as 'California'. If the city does not match the defined condition, then the state value is returned as 'Other'.
SELECT DISTINCT "City",
IF("City" = 'San Francisco','California','Other') AS "State"
FROM THIS_PROCESS


Result:


The query returns the following result.










Example with nested IF




The following example returns a distinct list of cities along with corresponding states. The first IF expression is used to compare the City to a literal value 'San Francisco'. If the city name matches the defined condition, the state value is returned as 'California'. If the city does not match the defined condition, the next nested IF expression is evaluated. If the state does not match the condition in the last IF expression, then the state value is returned as 'Other'.
SELECT DISTINCT "City",
IF("City" = 'San Francisco','California',
IF("City" = 'Miami','Florida',
IF("City" = 'Houston','Texas','Other'))) AS "State"
FROM THIS_PROCESS


Result:


The query returns the following result.











﻿
















Window Partition




The PARTITION BY clause defines the group of rows which the window function operates with. You can add multiple expressions after the PARTITION BY. For example:




- 
PARTITION BY attr, ...




- 
PARTITION BY attr, … ORDER BY attr, ...








Syntax


SELECT column name, SUM(column name) OVER (PARTITION BY column name)



Parameter | Description
column name | The column name in your table you want to include in the function.

SELECT column name, SUM(column name) OVER (PARTITION BY column name ORDER BY column name)



Parameter | Description
column name | The column name in your table you want to include in the function.





Examples




Example 1




Consider the following table:



City | Value
Berlin | 1000
Berlin | 1800
Paris | 3000
London | 2500
Paris | 1500
London | 1200
Berlin | 1300

SELECT city, SUM(value) OVER (PARTITION BY city)


A grouped sum is returned:



City | Value
Berlin | 4100
Berlin | 4100
Berlin | 4100
Paris | 4500
Paris | 4500
London | 3700
London | 3700



Example 2




Consider the following table:



City | Value
Berlin | 1000
Berlin | 1800
Paris | 3000
London | 2500
Paris | 1500
London | 1200
Berlin | 1300



Now an ORDER BY is added to the function:
SELECT city, SUM(value) OVER (PARTITION BY city ORDER BY value)


The cumulative sums per city are returned:



City | Value
Berlin | 1000
Berlin | 2300
Berlin | 4100
London | 1200
London | 3700
Paris | 1500
Paris | 4500






﻿
















Aggregate Functions




Use aggregate functions to reduce lists of values down to a single value.




AVG




Calculates the average of a collection of numeric values. NULL values are ignored.




Syntax



AVG(column_name)



Parameter | Description | Valid Types
column_name | The column of values to be averaged. | Number, Timestamp, Duration | Number, Timestamp, Duration
Number, Timestamp, Duration



Returns:
 The average as a Number, Timestamp or Duration. The return type matches the type of the 

```
column_name
```

 parameter.




Example





This query returns the average order amount of all cases.
SELECT AVG("Order Amount")
FROM THIS_PROCESS




SUM




Calculates the sum of all values in a collection of numeric values. NULL values are ignored.




Syntax



SUM(column_name)



Parameter | Description | Valid Types
column_name | The column of values to be summed. | Number, Duration



Returns:
 The sum as a Number or Duration. The return type matches the type of the 

```
column_name
```

 parameter.




Example





This query returns the total order amount in Boston.
SELECT SUM("ORDER AMOUNT")
FROM THIS_PROCESS
WHERE("City" = 'Boston')




COUNT




Counts the number of values in a specified column. NULL values aren't counted.




Syntax



COUNT(column_name)       



Parameter | Description | Valid Types
column_name | The column whose values are to be counted. | Any



Returns:
 The number of values in the provided collection of values.




Example





This query returns the number of cases.
SELECT COUNT(case_id)
FROM THIS_PROCESS




COUNT (DISTINCT)




Counts the number of distinct values in a specified column. If NULL values are present, they are excluded.


In the case of counting event-level columns, since event-level columns are lists, this function counts the number of distinct lists.




Syntax



COUNT(DISTINCT column_name)




Parameter | Description | Valid Types
column_name | The column whose distinct values are to be counted. | Number, Text, Timestamp, List (i.e. event-level column)



Returns:
 The number of distinct values in the provided collection of values.




Example 1 (Case-level)





This query returns the number of distinct cities.
SELECT COUNT(DISTINCT city)
FROM THIS_PROCESS




Example 2 (Event-level)





This query counts the number of distinct event sequences per case. Each distinct sequence represents a process variant, therefore this query returns the number of process variants.
SELECT COUNT(DISTINCT event_name)
FROM THIS_PROCESS




MIN




Finds the minimum value in a collection of numeric values.




Syntax



MIN(column_name)



Parameter | Description | Valid Types
column_name | The column from which the minimum value is chosen. | Number, Timestamp, Duration



Returns:
 The minimum value as a Number, Timestamp or Duration. The return type matches the type of the 

```
column_name
```

 parameter.




Example





This query returns the smallest discount.
SELECT MIN(discount)
FROM THIS_PROCESS




MAX




Finds the maximum value in a collection of numeric values.




Syntax



MAX(column_name)        



Parameter | Description | Valid Types
column_name | The column from which the maximum value is chosen. | Number, Timestamp, Duration



Returns:
 The maximum value as a Number, Timestamp or Duration. The return type matches the type of the 

```
column_name
```

 parameter.




Example





This query returns the largest discount.
SELECT MAX(discount)
FROM THIS_PROCESS




FIRST




Returns the first element from a collection of values.




Syntax



FIRST(column_name)




Parameter | Description | Valid Types
column_name | The column from which the first value is chosen. | Number,
Timestamp,
Duration,
Text,
Boolean



Returns:
 The first value as a Number, Timestamp, Duration, Text or Boolean. The return type matches the type of the 

```
column_name
```

 parameter.




Example





This query returns the name of the first event in this process.
SELECT
    (SELECT FIRST(event_name))
FROM THIS_PROCESS




LAST




Returns the last element from a collection of values.




Syntax



LAST(column_name)




Parameter | Description | Valid Types
column_name | The column from which the last value is chosen. | Number,
Timestamp,
Duration,
Text,
Boolean



Returns:
 The last value as a Number, Timestamp, Duration, Text or Boolean. The return type matches the type of the 

```
column_name
```

 parameter.




Example





This query returns the name of the last event in this process.
SELECT
    (SELECT LAST(event_name))
FROM THIS_PROCESS




BOOL_OR




Returns true if the supplied expression evaluates to true for any input row, otherwise it returns false.




Syntax



BOOL_OR(expression)



Parameter | Description | Valid Types
expression | An expression applied to a collection of rows. | Boolean



Returns:
 A Boolean. Result is true if any input row evaluates to true for the supplied expression, otherwise false.




Example





This query returns true if any row records an approval performed by a manager.
SELECT
    (SELECT BOOL_OR(event_name = 'Approve' AND performer = 'Manager'))
FROM THIS_PROCESS




BOOL_AND




Returns true if the supplied expression evaluates to true for all input rows, otherwise it returns false.




Syntax



BOOL_AND(expression)



Parameter | Description | Valid Types
expression | An expression applied to a collection of rows. | Boolean



Returns:
 A Boolean. Result is true if all input rows evaluate to true for the supplied expression, otherwise false.




Example





This query returns true if all rows record an approval performed by a manager.

```
SELECT
    (SELECT BOOL_AND(event_name = 'Approve' AND performer = 'Manager'))
FROM THIS_PROCESS
```





PERCENTILE_CONT




Returns the calculated continuous percentile, that is a value that corresponds to the specified fraction in the ordering. The calculation depends on the value position. The calculated value separates the lower from the upper percentile. If the value position is a fraction, the value will be interpolated between the two adjacent values.




Syntax



PERCENTILE_CONT(p) WITHIN GROUP(ORDER BY(expression))       



Parameter | Description | Valid Types
p | Percentile rank, for example 0.50. | Number (literal)
expression | The column of which you want to determine the value that separates the lower from the upper percentile for the given percentile rank. | Number, Timestamp, Duration



Returns:
 The calculated continuous percentile as a Number, Timestamp or Duration. The return type matches the type of the 

```
expression
```

 parameter.




Example





Column A:



Row | Value
1 | 65
2 | 72
3 | 81
4 | 95
5 | 112
6 | 128

SELECT
PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY A)
FROM THIS_PROCESS


This query determines in a first step the value position = 1.5. Because it's a fraction, the result value is the average of position 1 and 2 = 68.5. Values below 68.5 are in the lower percentile, values above 68.5 are in the upper percentile.


For p = 0.75, the result is as follows: value position = 4.5. The result value is the average of position 4 and 5, that is 103.5.




PERCENTILE_DISC




Returns the calculated discrete percentile, that is a value that corresponds to the specified fraction in the ordering. The calculation depends on the value position. The calculated value separates the lower from the upper percentile. If the value is a fraction, the higher value is taken.


This function supports all data types except strings.




Syntax



PERCENTILE_DISC(p) WITHIN GROUP(ORDER BY(expression))



Parameter | Description | Valid Types
p | Percentile rank, for example 0.50. | Number (literal)
expression | The column of which you want to determine the value that separates the lower from the upper percentile for the given percentile rank. | Any



Returns:
 The calculated discrete percentile. The return type matches the type of the 

```
expression
```

 parameter.




Example





Column A:



Row | Value
1 | 65
2 | 72
3 | 81
4 | 95
5 | 112
6 | 128

SELECT
PERCENTILE_DISC(0.25) WITHIN GROUP (ORDER BY A)
FROM THIS_PROCESS


This query determines in a first step the value position = 1.5. Because it's a fraction, the result value is the value of the higher position, that is 72. 




MEDIAN




A shortcut for the PERCENTILE_CONT function with a fixed percentile of 0.5, that is the middle number. 




Syntax



MEDIAN(column_name)



Parameter | Description | Valid Types
column_name | The column of which you want to determine the value that separates the lower from the upper half. | Number, Timestamp, Duration



Returns:
 The median value as a Number, Timestamp or Duration. The return type matches the type of the 

```
column_name
```

 parameter.




Example





This query calculates the median of a set of numerical values.


Column A:



Row | Value
1 | 65
2 | 72
3 | 81
4 | 95
5 | 112
6 | 128

SELECT
MEDIAN(A)
FROM THIS_PROCESS


The query determines in a first step the value position = 3. Because the sorted list has an even number of items, this query calculates  the arithmetic mean, that is (81 + 95)/2 = 88.




STDDEV




Calculates the standard deviation for a collection of values. The standard deviation describes the average deviation of all measured values from the mean value and indicates the spread.




Syntax



STDDEV(expression)


Parameters





 | Description | Valid Types
expression | The collection of values for which you want to determine the standard deviation. | Number, Timestamp, Duration



Returns:
 The standard deviation as a Number, Timestamp or Duration. The return type matches the type of the 

```
expression
```

 parameter.




Example





This query returns the standard deviation of all order amounts.
SELECT
STDDEV("Order Amount in EUR")
FROM THIS_PROCESS





﻿
















 syntax




The syntax of 
 is based on SQL but enhanced with functions to run in-depth process analysis queries. All queries always follow this basic structure:
SELECT expressions
FROM table /process
WHERE conditions






Example












This query counts the cases in the declared table for which the condition is true.








Syntax notation




The notation for the query syntax follows these notation rules. Note that this notation is not part of the query:




- 
The square brackets indicate optional parts.
Example: [WHERE condition]




- 
The pipe symbol indicates a choice between two or more options.
 Example: ASC | DESC




- 
The curly brackets indicate a list of choices or alternatives.
Example: {ASC|DESC}




- 
The text in italicize indicates a variable input with values of your choice.
Example: [ORDER BY expression DESC]




- 
An ellipsis  indicates the preceding element of a statement.








Keywords




Keywords are always written in uppercase. This allows to distinguish them from user expressions.   Read more on keywords in section 
 keywords
.




Attributes 




Attribute names are not case-sensitive. In the following cases, the attribute name must be enclosed in double quotes:




- 
The attribute is named like a reserved  keyword.




- 
The attribute does not start with a letter or an underscore.




- 
The attribute name contains characters other than letters, numbers, or underscores.




- 
If the attribute name is enclosed in double quotes, the entire expression must be enclosed in double quotes. 
Example: "Premium User" -> ""Premium User""




- 
If the attribute name contains one or more double quotes, these double quotes must be followed by a double quote.
Example: Width in " (inches) -> "Width in "" (inches)"




- 
If the attribute name contains one or more single quotes, these single quotes must be followed by a double quote.
Example: O'Reilly -> "O'"Reilly"






Attribute values are case-sensitive. They must always be enclosed in single quotes.


For 
, the following pre-defined semantic attributes are always present:




- case_id: Unique identifier of the case



- event_name: Event names of the case ordered by their time



- end_time: End timestamps of the events of a case



- start_time: Start timestamps of the events of a case, can be null if not available in the source data





The syntax rules for semantic attributes are the same as for the other attributes.





﻿
















FLATTEN operator




The FLATTEN operator flattens the nested table with the event attributes in a way that each event attribute becomes a top-level row. Case attributes are repeated accordingly.


Do not combine the FLATTEN operator with the MATCHES operators. The MATCHES operators work only for nested tables and not for flattened tables.


Nested table before flattening:








Table after flattening:








The flattened table allows to perform aggregations based on event names or other event attributes.


Syntax
:
SELECT expression
FROM FLATTEN (tablename)




Parameter | Description
expression | The column or expression that is queried, involving both case-level attributes and event-level attributes.
tablename | The nested table from which you want to retrieve records.



Example 1
: Flatten a nested table
SELECT case_id,"Customer ID", "Order Status", "City", "event_name", "end_time"
FROM FLATTEN (THIS_PROCESS)



This query creates a flattened table (see flattened table above) that allows further aggregations on event attribute-level.


Example 2
: Count number of cases that include a specific event
SELECT COUNT (DISTINCT case_id), "event_name"
FROM FLATTEN (THIS_PROCESS)
GROUP BY 2



This query returns the total number of cases in which each event occurs.











﻿
















Linear regression functions




With the linear regression functions, you can calculate the relationship between two variables using the least squares regression method, which is a standard approach for calculating a linear relationship. The least squares regression line, also called the line of best fit, can be visualized as a straight line drawn through a set of data points that represents the relationship between them.


For the regression line calculation, you need two parameters, slope and intercept. The slope and intercept show how two variables are related according to an average rate of change. This works well with scatter plots because scatter plots show two variables. The regression line is plotted on a scatter plot of the same data to show the general data trend.


The purpose of the linear regression function is to find the relationship between the explanatory variable, X and the dependent variable, Y. It predicts the value of Y when the value of X is known. 




Where to use linear regression






- 
The primary purpose of the linear regression function is to facilitate the plotting of regression lines in  widget. 




- 
 You can also use the linear regression function within custom SQL statements to calculate trend or regression values. This is useful for making predictions that extend beyond the provided data. For example, you have order value plotted against quantity and you want to know the value of an order size that is 10 times the maximum order size within your dataset.








Linear regression formula and functions




A linear regression line has an equation of the form: 
Y = a + bX


X
 is the explanatory variable and 
Y
 is the dependent variable.


a
 = intercept (the value of Y when X = 0) and
       
b
 = slope.


Following are the two functions implemented  to support the linear regression:




- 
regr_slope(Y, X) function: slope of the least-squares-fit linear equation determined by the (X, Y) pairs




- 
regr_intercept(Y, X) function: Y-intercept of the least-squares-fit linear equation determined by the (X, Y) pairs






The slope indicates the steepness of the regression line, whereas the intercept indicates its intersection with the Y axis. The Y-intercept is the point at which the graph intersects the Y-axis. Based on the slope of each X-axis unit, the subsequent point on the Y-axis is determined.




Syntax


REGR_INTERCEPT(Y attribute,X attribute),
REGR_SLOPE(Y attribute,X attribute)



Parameter | Description
Y attribute | Y is the dependent variable and it is plotted along the Y axis of a scatterplot.
X attribute | X is the explanatory variable and it is plotted along the X axis of a scatterplot.





Examples






Example 1




The following query correlates the order amount with order quantity and return values for intercept and slope.
SELECT 
    REGR_INTERCEPT("Order Amount" , "Order Quantity") as "Intercept", 
    REGR_SLOPE("Order Amount" , "Order Quantity") as "Slope"
FROM THIS_PROCESS      


Result:


The query returns the following result.








Following is the scatter plot generated using 
 widget in a process. It shows the scatter plot and regression line for order amount plotted against order quantity. 










Example 2




The following query calculates the order value along the regression line relative to an order size that is not included in your data set.
SELECT 300 as "Quantity","intercept" + 300 * "slope" as "Amount"
FROM 
(
  SELECT 
    REGR_INTERCEPT("Order Amount" , "Order Quantity") as "intercept", 
    REGR_SLOPE("Order Amount" , "Order Quantity") as "slope"
  FROM THIS_PROCESS
) as sub      


Result:


The query returns the following result.










Example 3




The following query calculates the order value along the regression line relative to an order size that is not included in  your data set and grouped by City.
SELECT "City",
  300 as "Quantity",
  "intercept" + 300 * "slope" as "Amount"
FROM
(
  SELECT "City",
    REGR_INTERCEPT("Order Amount" , "Order Quantity") as "intercept", 
    REGR_SLOPE("Order Amount" , "Order Quantity") as "slope"
  FROM THIS_PROCESS
  GROUP BY 1
) as sub	
	


Result:


The query returns the following result.








 





﻿


















Numeric Rounding Functions




The numeric rounding functions simplify calculations by converting floating-point numbers to an approximate value that is shorter, clearer, and easier to remember. 


These functions help group data, set threshold values for comparisons or histogram bucketing, and calculate complex value expressions such as cost or duration.




Functions and Syntax




Following are the numeric rounding functions:



Function | Description | Syntax
CEIL | The ceiling function returns the nearest integer greater than or equal to the provided numeric value by rounding towards positive infinity.
For example, 

- 
10.56 is rounded to 11


- 
 -10.56 is rounded to -10 | CEIL(numericAttribute)
FLOOR | The floor function returns the nearest integer less than or equal to the provided numeric value by rounding towards negative infinity. 
For example, 

- 
 10.56 is rounded to 10


- 
-10.56 is rounded to -11 | FLOOR(numericAttribute)
ROUND | The round function returns the nearest integer value to the provided numeric value.
For example,

- 
 10.45 is rounded to 10 


- 
10.56 is rounded to 11


- 
-10.45 is rounded to -10


- 
 -10.5 is rounded to -11 | ROUND(numericAttribute)
TRUNC | The truncate function returns the integer part of the provided numeric value by rounding towards zero.
For example, 

- 
 10.45 is rounded to 10


- 
-10.5 is rounded to -10 | TRUNC(numericAttribute)



 



Parameter | Description
numericAttribute | A numeric column or literal value.





Examples






Example 1




The following query returns the order amount rounded up or down to the nearest integer value based on the specified function.
SELECT "case_id", 
	"Order Amount",
	CEIL("Order Amount") AS "Order Amount - Ceiling",
	FLOOR("Order Amount") AS "Order Amount - Floor",
	ROUND("Order Amount") AS "Order Amount - Round",
	TRUNC("Order Amount") AS "Order Amount - Truncated",
FROM THIS_PROCESS
LIMIT 10


Result:


The query returns the following result.










Example 2




The following query shows how each function rounds up the negative values.
SELECT CEIL(-1.5) AS "Literal -1.5 - Ceiling",
			FLOOR(-1.5) AS "Literal -1.5 - Floor",
			ROUND(-1.5) AS "Literal -1.5 - Round",
			TRUNC(-1.5) AS "Literal -1.5 - Truncated"  
FROM THIS_PROCESS
LIMIT 1


Result:


The query returns the following result.








 





﻿
















Ranking Functions




Ranking functions are window functions that sort data partitions and assign a rank value for each row within a result set.


Using these functions, you can filter the results and sort them for consistent stacking in visualizations such as stacked bar charts.


Ranking functions, as follows:




- 
ROW_NUMBER(): Returns sequential row numbers.




- 
RANK(): Returns the rank for each row in a partition, with gaps in the ranking values.




- 
DENSE_RANK(): Returns the rank for each row in a partition, with no gaps in the ranking values.








ROW_NUMBER




Returns the calculated row number based on partitioned and sorted set of values. 


The ranking happens sequentially based on the order defined in the OVER clause for each partition. The rank value is different even if the rows contain the same values.




Syntax


ROW_NUMBER() OVER ( [PARTITION BY 
expression
 [,
expression
, ...] ] [ORDER BY 
expression
 [ { ASC | DESC } ] [, 
expression
, ...] ] )



Parameters | Description
expression | The column or argument that determines how the rows are grouped and how each partition is sorted. Mandatory if PARTITION BY or ORDER BY clauses are included in the query.



PARTITION BY: Splits the result set into partitions. Optional.


ORDER BY: Sorts each partition based on the defined criteria. Optional.


ASC | DESC: ASC sorts the result set in ascending order and DESC sorts it in descending order based on the expressions defined in ORDER BY.




Example




In the following query, the order amount  is first partitioned based on the city and the type of good. The query then returns the order amount ranked in descending order in the result set.

SELECT "Type of Goods",
       "City", 
       "Order Amount",
       ROW_NUMBER() OVER (PARTITION BY "Type of Goods", "City"  ORDER BY "Order Amount" DESC)
FROM THIS_PROCESS
WHERE "Order Amount" > 1500
ORDER BY 1, 2, 4        






Result:


















RANK




Returns the rank of each row in a result set based on the order defined in the OVER clause for each partition.


The RANK function assigns the same ranking for rows with identical values and skips the rank positions for these identical rows. For example, rows with rank values, 1, 2, 2, 2, 5, 6. The rank value of the next nonidentical row depends on the number of rows with same ranking. The number of rows with the same ranking determines the number of rank values to be skipped.




Syntax


RANK() OVER ( [PARTITION BY 
expression
 [,
expression
, ...] ] [ORDER BY 
expression
 [ { ASC | DESC } ] [, 
expression
, ...] ] )



Parameters | Description
expression | The column or argument determining how the rows are grouped and how each partition is sorted. Mandatory if PARTITION BY or ORDER BY clauses are included in the query.



PARTITION BY: Splits the result set into partitions. Optional.


ORDER BY: Sorts each partition based on the defined criteria. Optional.


ASC | DESC: ASC sorts the result set in ascending order and DESC sorts it in descending order based on the expressions defined in ORDER BY.




Example




In the following query, the cities are first partitioned by the type of good and sorted by the  count of high value orders per Type of Goods. The query then returns the cities with order amount greater than 1500 ranked in descending order.

SELECT "Type of Goods",
       "City", 
	count(case_id) AS "Orders > $1500",
       ROW_NUMBER()OVER (PARTITION BY "Type of Goods" ORDER BY count(case_id) DESC) AS "ROW_NUMBER",
       RANK()OVER(PARTITION BY "Type of Goods" ORDER BY count(case_id) DESC) AS "RANK"
FROM THIS_PROCESS
WHERE "Order Amount" > 1500
GROUP BY 1,2                                                                     






Result:


















DENSE_RANK




Returns the rank of each row in a result set based on the order defined in the OVER clause for each partition.


The DENSE_RANK function assigns the same ranking for rows with identical values and doesn't skip the rank positions for these identical rows. For example, rows with rank values, 1, 2, 2, 2, 3, 4. The rank value of the next nonidentical row will have the succeeding rank.




Syntax


DENSE_RANK() OVER ( [PARTITION BY 
expression
 [,
expression
, ...] ] [ORDER BY 
expression
 [ { ASC | DESC } ] [, 
expression
, ...] ] )



Parameters | Description
expression | The column or argument determining how the rows are grouped and how each partition is sorted. Mandatory if PARTITION BY or ORDER BY clauses are included in the query.



PARTITION BY: Splits the result set into partitions. Optional.


ORDER BY: Sorts each partition based on the defined criteria. Optional. If ORDER BY clause isn't included in your query, each row will have the same rank value, one.


ASC | DESC: ASC sorts the result set in ascending order and DESC sorts it in descending order based on the expressions defined in ORDER BY.




Example 1




In the following query, the cities are first partitioned by the type of good and sorted by the  count of high value orders per Type of Goods. The query then returns the cities with order amount greater than 1500 ranked in descending order.
SELECT "Type of Goods",
	"City",
	count(case_id) AS "Orders > $1500",
	ROW_NUMBER()OVER (PARTITION BY "Type of Goods" ORDER BY count(case_id) DESC) AS "ROW_NUMBER",
	RANK()OVER(PARTITION BY "Type of Goods" ORDER BY count(case_id) DESC) AS "RANK",
	DENSE_RANK() OVER (PARTITION BY "Type of Goods" ORDER BY count(case_id) DESC) AS "DENSE_RANK"
FROM THIS_PROCESS
WHERE "Order Amount" > 1500
GROUP BY 1,2                                                                     






Result:


















Example 2




 The following query partitions the result set by the type of goods and returns the list of cities with order amount greater than 1500 within a partition. In the result set, the RANK and DENSE RANK of all the returned rows is one as the ORDER BY clause isn't included in the query.
SELECT "Type of Goods",
       "City", 
	count(case_id) AS "Orders > $1500",
        ROW_NUMBER() OVER () AS "ROW_NUMBER",
        RANK() OVER () AS "RANK",
        DENSE_RANK() OVER () AS "DENSE_RANK"
FROM THIS_PROCESS
WHERE "Order Amount" > 1500






Result:



















﻿
















Date Functions




This section explains the date functions available in 
 queries.


Use date functions to execute operations on date and time values.




The default timestamp format in
 is dd/mm/yyyy.






DATE_TRUNC




Truncates the displayed precision level of timestamps. Truncation in this context means that all precision levels below the truncated date part of the timestamp are displayed as "01". For example, if you truncate the timestamp with precision level "year", all months and days are set to "01".




Syntax


DATE_TRUNC(precision, expression)



Parameter | Description | Valid Types
precision | The precision level in single quotes for the timestamp that is returned.
Available values:

- 
'year'


- 
'quarter'


- 
'month'


- 
'week' (ISO 8601-week numbering is applied)


- 
'day'


- 
'hour'


- 
'minute'


- 
'second'


- 
'millisecond' | Text (literal)
expression | The timestamp you want to truncate. | Timestamp



Returns:
 A Timestamp with the specified truncated level of precision.




Examples


SELECT
DATE_TRUNC('day', (SELECT FIRST(END_TIME))) AS "Truncated (day)",
DATE_TRUNC('month', (SELECT FIRST(END_TIME))) AS "Truncated (month)",
DATE_TRUNC('year', (SELECT FIRST(END_TIME))) AS "Truncated (year)"
FROM THIS_PROCESS


This query returns the given timestamps with truncated date parts:




- 
DATE_TRUNC('day') returns the timestamps unmodified because precision levels below "day" are not displayed.




- 
DATE_TRUNC('month') returns the timestamps with all precision levels below month are set to "01", that is 01/mm/yyyy.




- 
DATE_TRUNC('year') returns the timestamps with all precision levels below year are set to "01", that is 01/01/yyyy.










Example output:


















DATE_PART




Extracts a date part from a given timestamp. For example, you can display the month and week of a timestamp in separate columns or you can display date information that is not displayed by default, for example the hour.




Syntax


DATE_PART(precision, expression)



Parameter | Description | Valid Types
precision | The precision level in single quotes for the timestamp that is returned.
Available values:

- 
'year'


- 
'quarter'


- 
'month'


- 
'week' (ISO 8601-week numbering is applied)


- 
'day'


- 
'day_of_week' (returns 0 – 6, beginning with Sunday = 0)


- 
'hour'


- 
'minute'


- 
'second'


- 
millisecond | Text (literal)
expression | The timestamp from which you want to extract a part. | Timestamp



Returns:
 A Number corresponding to the value of the extracted part of the date.




Example


SELECT "case_id",
(SELECT FIRST("end_time")) AS "Timestamp",
DATE_PART('day', (SELECT FIRST("end_time"))) AS "Day",
DATE_PART('day_of_week', (SELECT FIRST("end_time"))) AS "Day of week",
DATE_PART('week', (SELECT FIRST("end_time"))) AS "Week",
DATE_PART('month', (SELECT FIRST("end_time"))) AS "Month",
DATE_PART('year', (SELECT FIRST("end_time"))) AS "Year",
DATE_PART('hour', (SELECT FIRST("end_time"))) AS "Hour",
DATE_PART('minute', (SELECT FIRST("end_time"))) AS "Minute",
DATE_PART('second', (SELECT FIRST("end_time"))) AS "Second",
DATE_PART('millisecond', (SELECT FIRST("end_time"))) AS "Millisecond"
FROM THIS_PROCESS


This query extracts date parts from the timestamp of the cases and displays them in separate columns. If the underlying data doesn't provide the queried precision, the value is displayed as "0", as in this example for milliseconds.






Example output:


















NOW




Returns the current UTC timestamp.






What is UTC?














Syntax





```
NOW()
```





Returns:
 A Timestamp corresponding to the date and time at which the query is executed.




Example




In the following example, the output of the call to 

```
NOW
```

 becomes the 

```
expression
```

 parameter value for 

```
DATE_PART
```

. The result displays the current quarter at the time the query is executed.



```
SELECT NOW(), DATE_PART('quarter', NOW()) as "current_quarter"FROM THIS_PROCESS
```














﻿
















Arithmetic functions




Use the arithmetic functions to perform statistical calculations.




SQRT




Calculates the square root of a numeric expression.




Syntax



SQRT(expression)



Parameter | Description | Valid Types
expression | The value for which you want to calculate the square root. | Number



Returns:
 The square root of the argument as a Number.




Examples




Example 1




This query calculates the square root from the given argument. For expression = 9,  the result is 3.
SELECT SQRT(9)
FROM THIS_PROCESS


Example 2




This query calculates the square root from the order amounts.
SELECT SQRT("Order Amount in EUR")
FROM THIS_PROCESS




POW




Raises a base value to an exponent power.




Syntax



POW(base, exponent)



Parameter | Description | Valid Types
base | The value to be raised. | Number
exponent | The exponent power to raise by. | Number (literal)



Returns:
 A number, the base value raised to the exponent value.




Example


SELECT
POW(9, 2),
POW(9, 0.5),
POW(9, 0),
POW(9, 1)
FROM THIS_PROCESS


The table displays the results  of the four calculations:










LOG




Calculates the exponent of the equation x = b ^ (y) -> log (b,x) = y of a numeric expression.




Syntax



LOG(expression, base)      



Parameter | Description | Valid Types
expression | The value for which the logarithm is calculated. | Number
base | The base to which the logarithm is calculated. | Number (literal)



Returns:
 A Number, the logarithm of the value calculated to the specified base.




Example



SELECT
LOG(10, 1000),
LOG(3, 27),
LOG(2, 8)
FROM THIS_PROCESS


The table displays the results of the three calculations. In each case, the result is 3 (specifically, 10 ^ 
3
 = 8, 3 ^ 
3
 = 27, and 2 ^ 
3
 = 8).










SIGN




Returns the sign of a real number  of a numeric expression. The function is defined as follows:


 For a real number x, return:




- 
-1 if x < 0




- 
0 if x = 0




- 
1 if x > 0








Syntax



SIGN(expression)



Parameter | Description | Valid Types
expression | The value for which you want to extract the sign. | Number



Returns:
 A Number denoting the sign of the argument.




Example



SELECT
SIGN(10) AS Positive,
SIGN(0) AS Zero,
SIGN(-8) AS Negative
FROM THIS_PROCESS


The resulting table displays the signs of the three numeric expressions:










ABS




Returns the absolute value of an expression. For an expression, x, the non-negative value of x is returned regardless of its sign.




Syntax





```
ABS(expression)
```






Parameter | Description | Valid Types
expression | The value for which you want to calculate the absolute value. | Number



Returns:
 The absolute value of the argument as a Number.




Examples




Example 1




This example shows ABS applied to simple values.



```
SELECT ABS(-3) AS Negative,ABS(4) AS PositiveFROM THIS_PROCESS
```





The resulting table displays the absolute values of the two values:








Example 2




This example finds all changes to order quantities. Since changes can be negative or positive, this query returns only the magnitude of each change.



```
SELECT case_id, "Order Quantity Changed" AS Change, ABS("Order Quantity Changed") AS AbsChangeFROM FLATTEN(THIS_PROCESS) WHERE event_name = 'Change Order Quantity'
```





Even  where order sizes were reduced, those changes can be presented as absolute values.











﻿
















BUCKET function




The BUCKET() function calculates the indexes of values in a range of values (as buckets) that are equal in size. The bucket indexes can then be applied to an aggregate function, for example a COUNT() function, which counts the values within that bucket.


The BUCKET() function uses following parameters to calculate the bucket indexes as a positive integer number:




- 
The value to be bucketed (expression)




- 
The minimum value within the result range (min)




- 
The fixed width for each bucket (bucket_width)




- 
The total number of consecutive, non-overlapping buckets (#_inlier_buckets)






Syntax:


BUCKET(expression, min, bucket_width, #_inlier_buckets)





Parameter | Description
expression | Specify a column with numeric or duration values in the expression.
min | The starting value of the bucket. The values must be either numeric or duration values.
bucket_width | The width of the bucket. The value must be either a positive numeric or positive duration that is greater than zero.
#_inlier_buckets | The number of required buckets. The value must be a positive integer that is greater than or equal to one.



To understand the range of values in the bucket, you can first determine the bucket boundaries and then apply the boundaries to the BUCKET() function. To determine the bucket boundaries and then apply the boundaries to the BUCKET() function, use the following pattern:
SELECT
IF (b = 0, NULL, ((b - 1) * bucket_width) + min) AS bucket_start,
IF (b = #_inlier_buckets + 1, NULL, (b * bucket_width) + min) AS bucket_end,
value
FROM (
SELECT BUCKET(expression, bucket_start, bucket_width, #_inlier_buckets) AS b, COUNT(1) AS value
FROM ...
) AS sub


The bucket boundaries pattern isn't required for the BUCKET() function to work. It provides a useful way to understand the range of values in the bucket. The pattern defines the minimum and maximum values being aggregated in the bucket.


Example 1:


The following example calculates the bucket boundaries (bucket_start and bucket_end). Then aggregates the total number of cases based on 'Order Amount'. The cases are bucketed into intervals of 100€ (bucket_width).


The results are then calculated for 100 buckets (#_inlier_buckets) where the 'Order Amount' is greater than 1€ (min) and less than 10001€ (max). The maximum value is calculated with the following formula: min + bucket width x #_inlier_buckets = 1+ 100 x 100 = 10001.
SELECT
total_cases,
bucket_id,
IF (bucket_id > 100, -1, ((bucket_id-1) * 100) + 0) AS bucket_start,
IF (bucket_id > 100, -1, (bucket_id * 100) + 0) AS bucket_end
FROM (
SELECT
BUCKET("Order Amount", 1, 100,100) as bucket_id,
COUNT(case_id) as total_cases
FROM FLATTEN(THIS_PROCESS)
WHERE "Order Amount" is not null
GROUP BY 1
ORDER BY 1
) as sub


Result:








Example 2:


The following example aggregates the total number of cases based on the 'Order Amount'. The cases are bucketed into intervals of 100€ (bucket_width). The results are calculated for 10 buckets (#_inlier_buckets) where the 'Order Amount' is greater than 1€ (min) and less than 1001€ (max). The maximum value is calculated with the following formula: min + bucket width x #_inlier_buckets = 1 + 100 x 10 = 1001


The result displays in a breakdown widget. The values on the X axis represent the bucket ID. Buckets that contain at least one case within them are displayed. The cases that have a bucket value of 10 but exceed the maximum value are added into the outlier bucket. The outlier bucket has a bucket ID of 11.

SELECT
BUCKET("Order Amount", 1, 100,10) as order_amount,
COUNT(case_id)
FROM FLATTEN(THIS_PROCESS)
WHERE "Order Amount" is not null
GROUP BY 1
ORDER BY 1



Result:











﻿


















Literal expressions




Following are the list of literal expressions:




- 

String literal





- 

Number literal





- 

DATE/TIMESTAMP literal





- 

DURATION literal









String literal




String literals are always enclosed in single quotes. If a string literal contains one or more single quotes, these single quotes must be followed by a single quote.


Example: O'Reilly -> 'O''Reilly'




Number literal




For decimal literals, the following conventions apply:




- 
0-9 




- 
1.5 | .5 




- 
1e-10 | .5e+1000








DATE/TIMESTAMP literal




With the DATE/TIMESTAMP literal function, you specify a timestamp as a literal.


Syntax
:
DATE 'literal'
TIMESTAMP 'literal'



Parameter | Description
literal | The date or timestamp information, for example DATE '2019-12-24' and TIMESTAMP '2019-12-24T12:00:00' .





DURATION literal




With the DURATION function you specify a duration literal which is parsed into a time interval.


Syntax
:
DURATION 'literal'



Parameter | Description
literal | A numeric value to indicate the time and a string to indicate the time unit, for example '3weeks', '4days', '3hours', '5minutes', '6seconds', and '7milliseconds'.
Combined usage is possible, for example '1day1hour'.
For all duration strings, the singular and plural forms are supported.
You can also follow the standard ISO-8601, for example P1D6H30M.



Example
:
SELECT COUNT(case_id)
FROM THIS_PROCESS
WHERE (SELECT LAST(EndTime) - FIRST(EndTime)) > DURATION '10days'


This query returns the number of cases in this process with more than 10 days between the start time and the end time.





﻿
















TABLESAMPLE clause




With the TABLESAMPLE clause, you can specify either the absolute or percentage table fraction to be considered for the query. The table fraction is sampled randomly after the FROM clause is evaluated and before all other clauses.


Syntax
:
SELECT expression
FROM table
TABLESAMPLE sampling method (sampling amount) REPEATABLE (seed
)



Parameter | Description
expression | The column or expression that you want to retrieve.
table | The process table or view from which you want to retrieve records, referenced by explicit Process ID or the alias THIS_PROCESS.
sampling method | The sampling method. Currently, only EXACT is supported.
sampling amount | The sampling amount; either absolute or percentage.
seed | The optional seed number to be used for generating random numbers for the sampling method.



 
Example
:
SELECT "Order Amount in EUR", "Duration Order To Payment"
FROM (SELECT "Order Amount in EUR",
(SELECT LAST (end_time) FILTER (WHERE event_name = 'Receive Payment')) -
(SELECT FIRST (end_time) FILTER (WHERE event_name = 'Receive Customer Order')
) AS "Duration Order To Payment"
FROM THIS_PROCESS
WHERE ("Order Amount in EUR" IS NOT NULL) AND
((SELECT LAST (end_time) FILTER (WHERE event_name = 'Receive Payment')) -
(SELECT FIRST (end_time) FILTER (WHERE event_name = 'Receive Customer Order'))
IS NOT NULL))
AS sub_query
TABLESAMPLE EXACT(10 ROWS) REPEATABLE(123)



This query returns 10 rows sampled randomly from the specified table.








For 
TABLESAMPLE EXACT(10 PERCENT) REPEATABLE(123)
, the query returns 10 percent of the rows sampled randomly from the specified table.









